<section><h1>Our Toolbox</h1>
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
$code("code/variadic_templates_theory.html", "0", "1")$
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
<p $make_fragment("0")$>Can take any number of arguments</p>
<p $make_fragment("1")$>Implementation using <i>parameter pack expansion</i></p>
<div>$code("code/variadic_templates_theory.html", "2", "3")$</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p $make_fragment("4")$>TransformMany&lt;T1&gt; == TransformOne&lt;T1&gt;</p>
<p $make_fragment("5")$>TransformMany&lt;T1, T2&gt; == TransformTwo&lt;T1, T2&gt;</p>
</section>


<section><h2 style="color:#f7f749">Tuples and Functions</h2>
std::tuple(num, str) â‡’ func(num, str) ?
<ul>
<li $make_fragment("0")$>std::apply: Call function with tuple elements</li>
</ul>
<pre $make_fragment("1")$><code class="cpp">void PrintNumberAndString(int num, const char* str) {
  std::cout &lt;&lt; "Number: " &lt;&lt; num &lt;&lt; std::endl;
  std::cout &lt;&lt; "String: " &lt;&lt; str &lt;&lt; std::endl;
}

auto tuple = std::make_tuple(5, "Hello World");
std::apply(PrintNumberAndString, tup);
</code></pre>
<pre style="background:#121212" $make_fragment("2")$>
Number: 5
String: Hello World
</pre>
</section>


<section data-transition="slide-in fade-out"><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">template&lt;typename... T&gt;
std::tuple&lt;T...&gt; Decode(CPUContext&amp; cpu) {
  unsigned reg_index = 0;
  return                    FromRegister&lt;T&gt;(cpu.reg[reg_index++])      ;
}
</code></pre>
<pre style="width:100%;visibility:hidden"><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
</section>


<section data-transition="slide-out fade-in"><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">template&lt;typename... T&gt;
std::tuple&lt;T...&gt; Decode(CPUContext&amp; cpu) {
  unsigned reg_index = 0;
  return std::tuple&lt;T...&gt; { FromRegister&lt;T&gt;(cpu.reg[reg_index++]) ... };
}
</code></pre>
<pre style="width:100%" $make_fragment("0")$><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
<p $make_fragment("0")$>vs.</p>
<pre style="width:100%" $make_fragment("0")$><code class="cpp">  case SvcId::StartDma:
    auto dst_proc  = FromRegister&lt;Process*&gt;(cpu.reg[1]);
    auto dst_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[2]);
    auto src_proc  = FromRegister&lt;Process*&gt;(cpu.reg[3]);
    auto src_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[0]);
    auto data_size = FromRegister&lt;uint32_t&gt;(cpu.reg[4]);
    DoStartDma(dst_proc, dst_addr, src_proc, src_addr, data_size);
</code></pre>
</section>


<section><h2 style="color:#f6ba4a">Fold Expressions</h2>
<p>Pack expansion while applying an operator</p>
<p $make_fragment("0")$ style="margin-bottom:0">Syntax:</p>
<div $make_fragment("1")$>$code("code/foldexpr_theory.html", "1")$</div><p>&nbsp;</p><p>&nbsp;</p>
<div><pre $make_fragment("2")$><code class="cpp">AccumulateMany(twice, 5)     == twice(5)
AccumulateMany(twice, 5, 64) == twice(5)+twice(64)
</code></pre></div>
<ul>
<li $make_fragment("3")$>All binary operators supported &#8230;</li>
<li $make_fragment("4")$>&#8230; including the comma operator</li> <!-- Guess which one we'll fold over -->
</ul>
</section>


<section><h2 style="color:#f6ba4a">Fold Expressions</h2>
Smart register encoding:
<ul>
  <li>
  Sequentially apply this function on each input type:
  <pre style="width:100%"><code class="cpp">cpu->reg[reg_index++] = ToRegister&lt;T&gt;(t)</code></pre>
  </li>
  <li $make_fragment("2")$>Fold expression using comma!
<pre style="width:100%" $make_fragment("2")$><code class="cpp" style="padding-bottom:0">template&lt;typename... T&gt;
void Encode(const T&amp;... values) {
  unsigned reg_index = 0;
  ((cpu.reg[reg_index++] = ToRegister&lt;T&gt;(values)), ...);
}
</code></pre>
</li>
<li $make_fragment("3")$>
<pre style="width:100%" $make_fragment("2")$><code class="cpp" style="padding-bottom:0">auto outputs = std::apply(DoStartDma, inputs);
std::apply(Encode&lt;uint32_t,DmaObject*&gt;, outputs);
</code></pre>
  </li>
</ul>
</section>


<section><h2 style="color:#49f749">Function traits</h2>
<ul>
<li $make_fragment("0")$>Type traits: Get info about a type at compile-time</li>
<li $make_fragment("1")$>E.g: std::is_pointer, std::is_copy_constructible, &#8230;</li>
<li $make_fragment("2")$>Structure in pseudo-code:</li>
<div  $make_fragment("2")$ style="display:flex">
<pre><code class="cpp">struct is_pointer&lt;int*&gt; {
  bool value = true;
};
</code></pre>
<p style="width:10%">&nbsp;</p>
<pre><code class="cpp">struct is_pointer&lt;int&gt; {
  bool value = false;
};
</code></pre>
<p style="width:50%">&nbsp;</p>
</div>
<li $make_fragment("3")$>Function traits:
<ul>
<li>Type traits for functions</li>
<li $make_fragment("4")$>Get parameter list &amp; return type</li>
</ul>
</ul>
<br>
</section>


<section><h2 style="color:#49f749">Function Traits</h2>
<span class="fragment">
<pre style="width:100%"><code class="cpp">template&lt;typename F&gt;
struct FunctionTraits {
  using Args   = std::tuple&lt; /* Parameter list of F */ &gt;;
  using Result = /* Return type of F */;
};
</code></pre>
</span>
<span class="fragment">
<p>Implementations available in</p>
<ul>
  <li>Boost.FunctionTypes (C++98?)</li>
  <li>Boost.CallableTraits (C++11)<br><small class="footer">Standalone: https://github.com/badair/callable_traits</small></li>
</ul>
</span>
</section>


<section><h2 style="color:#49f749">Function Traits</h2>
<p>Minimal implementation for our use case</p>
<span class="fragment">
<pre style="width:100%"><code class="cpp">template&lt;typename F&gt;
struct FunctionTraits;

// Specialisation
template&lt;typename FuncResult, typename... FuncArgs&gt;
struct FunctionTraits&lt;Result(Args...)&gt; {
  using Args   = std::tuple&lt;FuncArgs...&gt;;
  using Result = FuncResult;
};
</code></pre>
Very limited, but good enough here
</span>
</section>
