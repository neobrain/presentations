<section><h1>Our Toolbox</h1>
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
<span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=0><span class="fragment fade-out" data-fragment-index=1><pre><code class="cpp">template&lt;typename F, typename T&gt;
T TransformOne(F func, T value) {
  return func(value);
}
</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=1><pre><code class="cpp">template&lt;typename F, typename T1, typename T2&gt;
std::tuple&lt;T1, T2&gt; TransformTwo(F func, T1 value1, T2 value2) {
  return std::tuple&lt;T1, T2&gt; { func(value1), func(value2) };
}
</code></pre>
</span></span>
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
<p class="fragment" data-fragment-index=0>Can take any number of arguments</p>
<p class="fragment" data-fragment-index=1>Implementation using <i>parameter pack expansion</i></p>
<div><span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=2><span class="fragment fade-out" data-fragment-index=3><pre><code class="cpp">template&lt;typename F, typename... T&gt;
std::tuple&lt;T...&gt; TransformMany(F func, T... values) {
  
}
</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=3><pre><code class="cpp">template&lt;typename F, typename... T&gt;
std::tuple&lt;T...&gt; TransformMany(F func, T... values) {
  return std::tuple&lt;T...&gt; { func(values) ... };
}
</code></pre>
</span></span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p class="fragment" data-fragment-index=4>TransformMany&lt;T1&gt; == TransformOne&lt;T1&gt;</p>
<p class="fragment" data-fragment-index=5>TransformMany&lt;T1, T2&gt; == TransformTwo&lt;T1, T2&gt;</p>
</section>


<section><h2 style="color:#f7f749">Tuples and Functions</h2>
std::tuple(num, str) â‡’ func(num, str) ?
<ul>
<li class="fragment" data-fragment-index=0>std::apply: Call function with tuple elements</li>
</ul>
<pre class="fragment" data-fragment-index=1><code class="cpp">void PrintNumberAndString(int num, const char* str) {
  std::cout &lt;&lt; "Number: " &lt;&lt; num &lt;&lt; std::endl;
  std::cout &lt;&lt; "String: " &lt;&lt; str &lt;&lt; std::endl;
}

auto tuple = std::make_tuple(5, "Hello World");
std::apply(PrintNumberAndString, tup);
</code></pre>
<pre style="background:#121212" class="fragment" data-fragment-index=2>
Number: 5
String: Hello World
</pre>
</section>


<section data-transition="slide-in fade-out"><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">template&lt;typename... T&gt;
std::tuple&lt;T...&gt; Decode(CPUContext&amp; cpu) {
  unsigned reg_index = 0;
  return                    FromRegister&lt;T&gt;(cpu.reg[reg_index++])      ;
}
</code></pre>
<pre style="width:100%;visibility:hidden"><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
</section>


<section data-transition="slide-out fade-in"><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">template&lt;typename... T&gt;
std::tuple&lt;T...&gt; Decode(CPUContext&amp; cpu) {
  unsigned reg_index = 0;
  return std::tuple&lt;T...&gt; { FromRegister&lt;T&gt;(cpu.reg[reg_index++]) ... };
}
</code></pre>
<pre style="width:100%" class="fragment" data-fragment-index=0><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
<p class="fragment" data-fragment-index=0>vs.</p>
<pre style="width:100%" class="fragment" data-fragment-index=0><code class="cpp">  case SvcId::StartDma:
    auto dst_proc  = FromRegister&lt;Process*&gt;(cpu.reg[1]);
    auto dst_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[2]);
    auto src_proc  = FromRegister&lt;Process*&gt;(cpu.reg[3]);
    auto src_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[0]);
    auto data_size = FromRegister&lt;uint32_t&gt;(cpu.reg[4]);
    DoStartDma(dst_proc, dst_addr, src_proc, src_addr, data_size);
</code></pre>
</section>


<section><h2 style="color:#f6ba4a">Fold Expressions</h2>
<p>Pack expansion while applying an operator</p>
<p class="fragment" data-fragment-index=0 style="margin-bottom:0">Syntax:</p>
<div class="fragment" data-fragment-index=1><span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=1><pre><code class="cpp">template&lt;typename F, typename... T&gt;
auto AccumulateMany(F func, T... values) {
  return (func(values) + ... );
}
</code></pre>
</span></span></div><p>&nbsp;</p><p>&nbsp;</p>
<div><pre class="fragment" data-fragment-index=2><code class="cpp">AccumulateMany(twice, 5)     == twice(5)
AccumulateMany(twice, 5, 64) == twice(5)+twice(64)
</code></pre></div>
<ul>
<li class="fragment" data-fragment-index=3>All binary operators supported &#8230;</li>
<li class="fragment" data-fragment-index=4>&#8230; including the comma operator</li> <!-- Guess which one we'll fold over -->
</ul>
</section>


<section><h2 style="color:#f6ba4a">Fold Expressions</h2>
Smart register encoding:
<ul>
  <li>
  Sequentially apply this function on each input type:
  <pre style="width:100%"><code class="cpp">cpu->reg[reg_index++] = ToRegister&lt;T&gt;(t)</code></pre>
  </li>
  <li class="fragment" data-fragment-index=2>Fold expression using comma!
<pre style="width:100%" class="fragment" data-fragment-index=2><code class="cpp" style="padding-bottom:0">template&lt;typename... T&gt;
void Encode(const T&amp;... values) {
  unsigned reg_index = 0;
  ((cpu.reg[reg_index++] = ToRegister&lt;T&gt;(values)), ...);
}
</code></pre>
</li>
<li class="fragment" data-fragment-index=3>
<pre style="width:100%" class="fragment" data-fragment-index=2><code class="cpp" style="padding-bottom:0">auto outputs = std::apply(DoStartDma, inputs);
std::apply(Encode&lt;uint32_t,DmaObject*&gt;, outputs);
</code></pre>
  </li>
</ul>
</section>


<section><h2 style="color:#49f749">Function traits</h2>
<ul>
<li class="fragment" data-fragment-index=0>Type traits: Get info about a type at compile-time</li>
<li class="fragment" data-fragment-index=1>E.g: std::is_pointer, std::is_copy_constructible, &#8230;</li>
<li class="fragment" data-fragment-index=2>Structure in pseudo-code:</li>
<div  class="fragment" data-fragment-index=2 style="display:flex">
<pre><code class="cpp">struct is_pointer&lt;int*&gt; {
  bool value = true;
};
</code></pre>
<p style="width:10%">&nbsp;</p>
<pre><code class="cpp">struct is_pointer&lt;int&gt; {
  bool value = false;
};
</code></pre>
<p style="width:50%">&nbsp;</p>
</div>
<li class="fragment" data-fragment-index=3>Function traits:
<ul>
<li>Type traits for functions</li>
<li class="fragment" data-fragment-index=4>Get parameter list &amp; return type</li>
</ul>
</ul>
<br>
</section>


<section><h2 style="color:#49f749">Function Traits</h2>
<span class="fragment">
<pre style="width:100%"><code class="cpp">template&lt;typename F&gt;
struct FunctionTraits {
  using Args   = std::tuple&lt; /* Parameter list of F */ &gt;;
  using Result = /* Return type of F */;
};
</code></pre>
</span>
<span class="fragment">
<p>Implementations available in</p>
<ul>
  <li>Boost.FunctionTypes (C++98?)</li>
  <li>Boost.CallableTraits (C++11)<br><small class="footer">Standalone: https://github.com/badair/callable_traits</small></li>
</ul>
</span>
</section>


<section><h2 style="color:#49f749">Function Traits</h2>
<p>Minimal implementation for our use case</p>
<span class="fragment">
<pre style="width:100%"><code class="cpp">template&lt;typename F&gt;
struct FunctionTraits;

// Specialisation
template&lt;typename FuncResult, typename... FuncArgs&gt;
struct FunctionTraits&lt;Result(Args...)&gt; {
  using Args   = std::tuple&lt;FuncArgs...&gt;;
  using Result = FuncResult;
};
</code></pre>
Very limited, but good enough here
</span>
</section>

