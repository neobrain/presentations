<section style="line-height:0.5"><h2>Our Vision</h2>
<pre style="width:100%"><code class="cpp">std::tuple&lt;Result, DmaObject*&gt;
DoStartDma(Process* dst_process, VAddr dst_data_addr,
           Process* src_process, VAddr src_data_addr,
           uint32_t data_size);
</code></pre>
<span class="fragment">
↓ <font color="#49f749">Function Traits</font> ↓
<pre style="width:100%"><code class="cpp">using InData  = FunctionTraits&lt;decltype(DoStartDma)&gt;::Args;
using OutData = FunctionTraits&lt;decltype(DoStartDma)&gt;::Result;
</code></pre>
<span class="fragment">
↓ <font color="#f6ba4a">Generators</font> ↓
<pre style="width:100%"><code class="cpp">InData Decode&lt;InData&gt;(CPU&amp; cpu)
void   Encode&lt;OutData&gt;(CPU&amp; cpu, OutData... data)
</code></pre>
<span class="fragment">
↓ <font color="#f7f749">Combine</font> ↓
<pre style="width:100%"><code class="cpp">case SvcId::StartDma:
  WrapSVCImpl&lt;DoStartDma&gt;(cpu);
  break;
</code></pre>
</span>
</span>
</span>
</section>

<section>Putting things together<br><h1>In Practice</h1>
</section>


<section><h2>In Practice — Setup</h2>
Dummy environment<br>Types:
<pre style="width:100%"><code class="cpp">struct CPU {
  uint32_t reg[16];
};

// Dummy kernel object types
struct Process {};
struct DmaObject {};

using VAddr = uint32_t;
</code></pre>
</section>

<section><h2>In Practice — Setup</h2>
Dummy environment<br>Stub handler:
<pre style="width:100%"><code class="cpp">std::tuple&lt;uint32_t, DmaObject*&gt;
DoStartDma(Process* dst_process, VAddr dst_addr,
           Process* src_process, VAddr src_addr, uint32_t data_size) {
  std::cout &lt;&lt; /* log input arguments */ &lt;&lt; std::endl;

  // Return some unique-ish dummy values
  return std::tuple(uint32_t{src_addr * dst_addr}, new DmaObject);
}
</code></pre>
</section>

<section><h2>In Practice — Setup</h2>
Dummy environment<br>Verbose conversion from CPU registers:
<pre style="width:100%"><code class="cpp">template&lt;typename T&gt;
T FromRegister(uint32_t value) {
  std::cout &lt;&lt; "Decoding value " &lt;&lt; value &lt;&lt; '\n';

  if constexpr (!std::is_pointer_v&lt;T&gt;) {
    return static_cast&lt;T&gt;(value);
  } else {
    // Just hack together some pointer based on the given value
    return reinterpret_cast&lt;T&gt;(static_cast&lt;uintptr_t&gt;(value));
  }
}</code></pre>
</section>

<section><h2>In Practice — Setup</h2>
Dummy environment<br>Verbose conversion from CPU registers:
<pre style="width:100%"><code class="cpp">template&lt;typename T&gt;
uint32_t ToRegister(T value) {
  std::cout &lt;&lt; "Encoding value " &lt;&lt; value &lt;&lt; '\n';

  if constexpr (!std::is_pointer_v&lt;T&gt;) {
    return static_cast&lt;uint32_t&gt;(value);
  } else {
    // Just return the raw object address as a value
    return static_cast&lt;uint32_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(value));
  }
}</code></pre>
</section>

<section><h2>In Practice — Decoder</h2>
<p $make_fragment("0")$ style="margin-top:-20px">Decode requires a parameter pack:</p>
<pre $make_fragment("0")$ style="width:100%"><code class="cpp">template&lt;typename... Args&gt;
std::tuple&lt;Args...&gt; Decode(CPU&amp; cpu) { /* ... */ }
</code></pre>
<p $make_fragment("2")$>… but FunctionTraits gave us a std::tuple</p>
<p $make_fragment("3")$>Let's try partial template specialisation:</p>
<pre $make_fragment("4")$ style="width:100%"><code class="cpp">template&lt;typename ArgsTuple&gt;
ArgsTuple Decode(CPU&amp;);

template&lt;typename... Args&gt;
std::tuple&lt;Args...&gt; Decode&lt;std::tuple&lt;Args...&gt;&gt;(CPU&amp;) {
  // ...
}
</code></pre>
<pre style="background:#121212; width:100%" $make_fragment("5")$><span style="color:red">error: </span>function template partial specialization is not allowed</pre>
</section>

<section><h2>In Practice — Decoder</h2>
<p>We can't partially specialise functions&#8230;</p>
<p $make_fragment("0")$>&#8230; but we can partially specialise function objects!</p>

<pre style="width:100%" $make_fragment("1")$><code class="cpp">template&lt;typename ArgsTuple&gt;
struct Decoder;

template&lt;typename... Args&gt;
struct Decoder&lt;std::tuple&lt;Args...&gt;&gt; {
  static std::tuple&lt;Args...&gt; Decode(CPU&amp; cpu) {
    size_t reg_index = 0;
    return std::tuple&lt;Args... &gt; {
             FromRegister&lt;Args&gt;(cpu.reg[reg_index++])
             ...
           };
  }
};
</code></pre>
</section>

<section><h2>In Practice — Encoder</h2>
<p $make_fragment("0")$>Similarly, the Encoder must be a function object too:</p>

<pre $make_fragment("1")$ style="width:100%"><code class="cpp">template&lt;typename ArgsTuple&gt;
struct Encoder;

template&lt;typename... Args&gt;
struct Encoder&lt;std::tuple&lt;Args...&gt;&gt; {
  CPU&amp; cpu;

  void operator()(Args... args) {
    size_t reg_index = 0;
    ((cpu.reg[reg_index++] = ToRegister&lt;Args&gt;(args)), ...);
  }
};
</code></pre>

<pre $make_fragment("3")$ style="width:100%"><code class="cpp">Encoder&lt;OutArgs&gt; encoder{cpu}; // construct stateful function object
std::apply(encoder, outputs);
</code></pre>
</section>


<section><h2>In Practice — The Glue</h2>
<pre style="width:100%"><code class="cpp" style="max-height:30em">template&lt;auto SVCImpl&gt;
void WrapSVCImpl(CPU&amp; cpu) {
  // Turn handler's function signature into std::tuples
  using InArgs = typename FunctionTraits&lt;decltype(SVCImpl)&gt;::InArgs;
  using OutArgs = typename FunctionTraits&lt;decltype(SVCImpl)&gt;::OutArgs;

  // Decode registers by calling stateless function object
  auto args = Decoder&lt;OutArgs, InArgs&gt;::Decode(cpu);

  // Call handler
  auto result = std::apply(SVCImpl, args);

  // Encode registers by calling stateful function object
  Encoder&lt;OutArgs&gt; encoder{cpu};
  std::apply(encoder, result);
}
</code></pre>
</section>

<section><h2>In Practice — The Result</h2>
<pre style="width:100%"><code class="cpp" style="max-height:30em">void HandleSVC(CPU&amp; cpu, uint32_t index) {
  switch (index) {
  // ...
  case 0x55:
    WrapSVCImpl&lt;DoStartDma&gt;(cpu);
    break;
  case 0x56:
    WrapSVCImpl&lt;DoStopDma&gt;(cpu);
    break;
  case 0x57:
    WrapSVCImpl&lt;GetDmaState&gt;(cpu);
    break;
  case 0x58:
    WrapSVCImpl&lt;DoRestartDma&gt;(cpu);
    break;
  // ...
  }
}
</code></pre>
</section>

<section><h2>In Practice — The Result</h2>
<pre style="width:100%"><code data-noescape class="cpp" style="max-height:30em">int main() {
  CPU cpu {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }};
  HandleSVC(cpu, 0x55);

  std::cout &lt;&lt; '\n' &lt;&lt; "CPU registers on return:" &lt;&lt; '\n';
  for (auto reg : cpu.reg)
    std::cout &lt;&lt; "0x" &lt;&lt; std::hex &lt;&lt; reg &lt;&lt; ' ';
}
</code></pre>

<p $make_fragment("0")$><a href="/live/live.cpp" target="_blank">Full example code online</a></p>
<p $make_fragment("1")$>g++&ensp;&#8211;std=c++1z&ensp;example.cpp</p>
</section>


<section><h2>In Practice — The Result</h2>
  <pre style="width:100%; margin-top:-20px"><code data-noescape class="cpp" style="max-height:30em">int main() {
  CPU cpu {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }};
  HandleSVC(cpu, 0x55);

  std::cout &lt;&lt; '\n' &lt;&lt; "CPU registers on return:" &lt;&lt; '\n';
  for (auto reg : cpu.reg)
    std::cout &lt;&lt; "0x" &lt;&lt; std::hex &lt;&lt; reg &lt;&lt; ' ';
}</code></pre>

  <pre style="background:#121212; width:100%" $make_fragment("1")$>
  Decoding value 0
  Decoding value <font color="Ultramarine Blue">1</font>
  Decoding value 2
  Decoding value <font color="Ultramarine Blue">3</font>
  Decoding value 4
  DoStartDma: dst_proc=0x0, dst_addr=1, src_proc=0x2, src_addr=3, size=4
              returning 3 and 0x240b280
  Encoding value <font color="#87cefa">3   = <font color="Ultramarine Blue">1</font> * <font color="Ultramarine Blue">3</font></font>
  Encoding value <font color="#32cd32">0x25ea280</font>

  CPU registers on return:
  <font color="#87cefa">0x3</font> <font color="#32cd32">0x25ea280</font> 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0x0 0x0 0x0 0x0 0x0 0x0
  </pre>
</section>


<section><h1>Conclusion</h1>
</section>


<section><h2>Conclusion</h2>
<ul>
  <li>Vastly simplified implementation</li>
    <ul><li>Easier to read, validate, and extend</li></ul>
  <li>Zero performance overhead</li>
  <li>Metaprogramming can be powerful <b>and</b> simple
    <ul><li>Especially in C++17</li></ul>
  </li>
<br>
</ul>

<p><b>The best code is the code you didn't have to write!</b></p>
</section>


<section><h2>Further Reading</h2>
<p><small $make_fragment("0")$>Introduction to template metaprogramming:<br>Arthur O'Dwyer, <a href="https://www.youtube.com/watch?v=vwrXHznaYLA" target="_blank">Template Normal Programming</a></small></p>
<p><small $make_fragment("1")$>Fold expressions in detail:<br>Vittorio Romeo, <a href="https://skillsmatter.com/skillscasts/11363-introduction-to-c-plus-plus-origami" target="_blank">Introduction to C++ origami</a></small></p>
</section>


<section><h1>THX &amp;&amp; FAQ ? OK : EOF</h1>
<div><a href="https://twitter.com/fail_cluez" target="_blank"><img src="images/Twitter_Logo_Custom.svg" height=75pt style="vertical-align:middle; border:none; background-color:transparent; box-shadow:none"><span style="font-family: 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif">@</span>fail_cluez</a></div>
<div><a href="https://github.com/neobrain" target="_blank"><img src="images/GitHub-Mark-Custom.svg" height=38px style="vertical-align:middle; border:none; background-color:transparent; box-shadow:none">&nbsp;&#8198;neobrain</a></div>
<img src="images/glitchedcube2.png" height="100em" style="border-radius:20px; vertical-align:middle; margin-top:36px">
</section>


<section><h1>Bonus</h1>
</section>


<section><h2>Counting Registers</h2>
<p>Decode() was cheating before:</p>

<pre style="width:100%; margin-top:-20px"><code data-noescape class="cpp" style="max-height:30em">size_t reg_index = 0;
return std::tuple&lt;Args... &gt; {
           FromRegister&lt;Args&gt;(cpu.reg[<span style="color:#e00">reg_index++</span>]) ...
       };
</code></pre>

<p $make_fragment("0")$>This doesn't reflect the proper register order:</p>
<p $make_fragment("0")$>r1 → r2 → r3 → r0 → r4</p>
<p $make_fragment("1")$>Luckily, we can just replace reg_index++ with</p>
<pre  $make_fragment("1")$ style="width:100%"><code data-noescape class="cpp" style="max-height:30em">template&lt;size_t first_reg&gt;
size_t GetAndThenUpdateRegIndex(size_t&amp; cur_index);
</code></pre>
</section>


<section><h2>Counting Registers</h2>
<p $make_fragment("0")$>Ad-hoc logic to reproduce the 3DS register order:</p>
<pre  $make_fragment("1")$ style="width:100%"><code data-noescape class="cpp" style="max-height:30em">template&lt;size_t first_reg&gt;
size_t GetAndThenUpdateRegIndex(size_t&amp; cur_index) {
  size_t old_index = cur_index;
  ++cur_index;
  if (cur_index == 4) cur_index = 0;
  if (cur_index == first_reg) cur_index = 4;
  return old_index;
}
</code></pre>
<pre  $make_fragment("1")$ style="width:100%"><code data-noescape class="cpp" style="max-height:30em">constexpr size_t first_reg = std::tuple_size_v&lt;OutData&gt; - 1;
</code></pre>
<ul>
<li $make_fragment("2")$ style="font-size:90%">Gets current index &amp; then advances cur_index inplace</li>
<li $make_fragment("4")$ style="font-size:90%">first_reg is determined by the number of output values</li>
</ul>
</section>


<section><h2>Counting Registers</h2>
<pre style="width:100%" $make_fragment("1")$><code class="cpp">template&lt;typename OutData, typename... Args&gt;
static std::tuple&lt;Args...&gt; Decode(CPU&amp; cpu) {
  constexpr size_t first_reg = std::tuple_size_v&lt;OutData&gt; - 1;
  size_t reg_index = first_reg;
  return std::tuple&lt;Args... &gt; {
             FromRegister&lt;Args&gt;(
                 cpu.reg[GetAndThenUpdateRegIndex&lt;first_reg&gt;(reg_index)])
             ...
         };
}</code></pre>
</section>


<section><h2>Counting Registers</h2>
<p $make_fragment("0")$><a href="/live/live_regcount.cpp" target="_blank">Adapted example code online</a></p>

<pre style="background:#121212; width:100%; font-size:50%" $make_fragment("1")$>
Decoding value 1
Decoding value <font color="Ultramarine Blue">2</font>
Decoding value 3
Decoding value <font color="Ultramarine Blue">0</font>
Decoding value 4
DoStartDma: dst_proc=0x1, dst_addr=2, src_proc=0x3, src_addr=0, size=4
            returning 0 and 0x240b280
Encoding value <font color="#87cefa">0   = <font color="Ultramarine Blue">2</font> * <font color="Ultramarine Blue">0</font></font>
Encoding value <font color="#32cd32">0x25ea280</font>

CPU registers on return:
<font color="#87cefa">0x0</font> <font color="#32cd32">0x25ea280</font> 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0x0 0x0 0x0 0x0 0x0 0x0
</pre>
</section>
