<section data-transition="slide-in fade-out"><h2>Emulating 3DS System Calls</h2>
Example handlers:<br>
<span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=0><span class="fragment fade-out" data-fragment-index=1><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em; overflow:hidden"><!--
--><!--
-->// No inputs, no outputs
void
DoExitProcess();<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::ExitCurrentProcess: // 0x3
    DoExitCurrentProcess();
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=1><span class="fragment fade-out" data-fragment-index=2><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em; overflow:hidden"><!--
--><!--
-->// One input, one output
uint32_t <!-- NOTE: Will return std::tuple<u32> later, but for now a plain u32 is better to convey the idea -->
DoSleepThread(uint32_t duration);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::SleepThread: // 0xa
    uint32_t duration_ns = FromRegister&lt;uint32_t&gt;(cpu.reg[0]);

    auto result = DoSleepThread(duration_ns);

    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(result); // result code
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=2><span class="fragment fade-out" data-fragment-index=3><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em; overflow:hidden"><!--
--><!--
-->// Three inputs, two outputs
std::tuple&lt;uint32_t, VAddr&gt;
DoControlMemory(uint32_t size, uint32_t perm, uint32_t mode);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::ControlMemory: // 0x1
    uint32_t size        = FromRegister&lt;uint32_t&gt;(cpu.reg[1]); 
    uint32_t mode        = FromRegister&lt;uint32_t&gt;(cpu.reg[2]);
    uint32_t permissions = FromRegister&lt;uint32_t&gt;(cpu.reg[3]);
    auto outputs = DoControlMemory(size, permissions, mode);
    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(std::get&lt;0&gt;(outputs)); // Error code
    cpu.reg[1] = ToRegister&lt;VAddr   &gt;(std::get&lt;1&gt;(outputs)); // Block address
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=3><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em; overflow:hidden"><!--
--><!--
-->// Three inputs, two outputs
std::tuple&lt;uint32_t, VAddr&gt;
DoControlMemory(uint32_t size, uint32_t perm, uint32_t mode);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::ControlMemory: // 0x1
    uint32_t size        = FromRegister&lt;uint32_t&gt;(cpu.reg[1]); <font color="red">/​/ Starts at r1??</font>
    uint32_t mode        = FromRegister&lt;uint32_t&gt;(cpu.reg[2]);
    uint32_t permissions = FromRegister&lt;uint32_t&gt;(cpu.reg[3]);
    auto outputs = DoControlMemory(size, permissions, mode);
    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(std::get&lt;0&gt;(outputs)); // Error code
    cpu.reg[1] = ToRegister&lt;VAddr   &gt;(std::get&lt;1&gt;(outputs)); // Block address
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span>
</section>


<section data-transition="fade-in slide-out"><h2>Emulating 3DS System Calls</h2>
<!-- Showing the CreateMutex and LockMutex handlers, now that the kernel objects have been introduced -->
Example handlers:<br>
<span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=0><span class="fragment fade-out" data-fragment-index=1><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em"><!--
--><!--
-->// No inputs, two outputs
std::tuple&lt;Result, Mutex*&gt;
DoCreateMutex();<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::CreateMutex: // 0x13
    auto outputs = DoCreateMutex();
    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(std::get&lt;0&gt;(outputs)); // Error code
    cpu.reg[1] = ToRegister&lt;Mutex*  &gt;(std::get&lt;1&gt;(outputs)); // Handle of created mutex
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=1><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em"><!--
--><!--
-->// One input, one output
Result
DoLockMutex(Mutex* mutex, uint32_t timeout);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::LockMutex: // 0x24
    Mutex*   mutex   = FromRegister&lt;Mutex*  &gt;(cpu.reg[0]);
    uint32_t timeout = FromRegister&lt;uint32_t&gt;(cpu.reg[1]);
    auto output = DoLockMutex(mutex, timeout);
    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(output);
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span>
</section>


<section><h2>Emulating 3DS System Calls</h2>
Common structure:
<ul>
<li class="fragment" data-fragment-index=0>Read inputs from CPU registers (cpu.reg[n])</li>
<ul><li class="fragment" data-fragment-index=1>Handle→Object* lookup via <span style=" vertical-align: baseline; font-family: monospace; font-size:60%">FromReg&lt;Object*&gt;(handle)</span></li></ul>
<li class="fragment" data-fragment-index=2>Invoke main handler: <span style="font-size:60%"><span style=" vertical-align: baseline; font-family: monospace">DoCreateMutex</span>, <span style=" vertical-align: baseline; font-family: monospace">DoLockMutex</span>,&#8230;</span></li>
<li class="fragment" data-fragment-index=3>Write outputs back to CPU registers</li>
<ul><li class="fragment" data-fragment-index=4>Object*⟶Handle via <span style=" vertical-align: baseline; font-family: monospace; font-size:60%">ToRegister&lt;Object*&gt;(object)</span></li></ul>
</ul>
</section>


<section><h2>Repetitive logic makes code ...</h2>
<ul style="margin-top:-20px">
<li class="fragment" data-fragment-index=0 style="line-height:1.1">Hard to write<br><small>more typing, mental arithmetic</small></li>
<li class="fragment" data-fragment-index=1 style="line-height:1.1">Hard to modify<br><small>consistency<!-- across instances-->? <!-- no compile-time consistency checking!--> </small></li>
<li class="fragment" data-fragment-index=2 style="line-height:1.1">Hard to document<br><small><!--discoverability: -->where to put docstrings?</small></li>
<li class="fragment" data-fragment-index=3 style="line-height:1.1">Hard to understand<br><small><!--hard to reason about -->scattered information<br>magic numbers<!-- are bad--></small></li>
<li class="fragment" data-fragment-index=4 style="line-height:1.1">Hard to review &amp; validate<br><small>"given enough eyeballs" notwithstanding</small></li> <!-- "given enough eyeballs, all bugs are shallow" not so much -->
</ul>

<p><b class="fragment" data-fragment-index=5>Don't Repeat Yourself</b><br>
<span class="fragment" data-fragment-index=6>But how?</span></p>
</section>


<section><h2>Enter Compile-time Programming</h2>
<p>Building blocks:</p>
<ul>
<li class="fragment" data-fragment-index=1><font color="#f6ba4a">Code generation</font>: <font color="#f7f749">Type lists</font> ⟶ <font color="#f64a4a">Runtime logic</font></li>
<li class="fragment" data-fragment-index=2><font color="#49f749">Reflection</font>: Capture <font color="#0049f7">code properties</font> in <font color="#f7f749">type lists</font></li>
<li class="fragment" data-fragment-index=3><font color="#f7f749">TMP</font>: Transform <font color="#f7f749">type list</font> into <font color="#f7f749">type lists</font></li>
</ul>

<img class="fragment" data-fragment-index=0 src="images/metaprogramming.svg" style="background:#2a2a2a">
</section>


<section><h2>Our Vision</h2>
<!-- Showing the DoStartDma handler -->
"Worst case" handler:<br>
<span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index=2><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em"><!--
--><!--
-->// Three inputs, two outputs
std::tuple&lt;uint32_t, DmaTracker*&gt;
DoStartDma(Process* dst_process, VAddr dst_addr,
           Process* src_proces, VAddr src_addr, uint32_t size);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::StartDma: // 0x1
    Process* dst_proc  = FromRegister&lt;Process*&gt;(cpu.reg[1]); 
    VAddr    dst_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[2]);
    Process* src_proc  = FromRegister&lt;Process*&gt;(cpu.reg[3]);
    VAddr    src_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[0]); 
    uint32_t data_size = FromRegister&lt;uint32_t&gt;(cpu.reg[4]); 
    auto outputs = DoStartDma(dst_proc, dst_addr, src_proc, src_addr, data_size);
    cpu.reg[0] = ToRegister&lt;uint32_t  &gt;(std::get&lt;0&gt;(outputs)); // Error code
    cpu.reg[1] = ToRegister&lt;DmaObject*&gt;(std::get&lt;1&gt;(outputs)); // DMA object
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span>
</section>


<section style="line-height:0.5"><h2>Our Vision</h2>
<pre style="width:100%"><code class="cpp">std::tuple&lt;Result, DmaObject*&gt;
DoStartDma(Process* dst_process, VAddr dst_data_addr,
           Process* src_process, VAddr src_data_addr,
           uint32_t data_size);
</code></pre>
<span class="fragment">
↓ <font color="#49f749">Function Traits</font> ↓
<pre style="width:100%"><code class="cpp">using InData  = std::tuple&lt;Process*, VAddr, Process*, VAddr, uint32_t>
using OutData = std::tuple&lt;Result, DmaObject*>
</code></pre>
<span class="fragment">
↓ <font color="#f6ba4a">Generators</font> ↓
<pre style="width:100%"><code class="cpp">template&lt;typename  InData&gt; InData Decode(CPU&amp; cpu)
template&lt;typename OutData&gt; void   Encode(CPU&amp; cpu, OutData... data)
</code></pre>
<span class="fragment">
↓ <font color="#f7f749">Combine</font> ↓
<pre style="width:100%"><code class="cpp">case SvcId::StartDma:
  WrapSVCImpl&lt;DoStartDma&gt;(cpu);
  break;
</code></pre>
</span>
</span>
</span>
</section>


<section><h2>Our Vision</h2>
What we end up with:
<pre><code class="cpp" data-trim data-noescape style="max-height:200em"><!--
-->std::tuple&lt;uint32_t, DmaTracker*&gt;
DoStartDma(Process* dst_process, VAddr dst_addr,
           Process* src_process, VAddr src_addr, uint32_t size)

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
  case SvcId::StartDma:
    WrapSVCImpl&lt;DoStartDma&gt;(cpu);
    break;
  // ...
  }
}
</code></pre>

</section>

