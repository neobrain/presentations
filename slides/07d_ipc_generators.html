<section><h2 style="color:$color_codegen$">Generators</h2>
TODO: Outline principle. Pack expansion/Fold expression
</section>

<section><h2 style="color:$color_codegen$">Generators</h2>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center">uint32<br>5</td><td style="text-align:center">uint64_lo<br>0xdeadbeef</td><td style="text-align:center">uint64_hi<br>0x5555</td><td style="text-align:center">uint64_lo<br>0xd00f</td><td style="text-align:center">uint64_hi<br>0</td><td style="text-align:center">buffer descriptor<br>…</td><td style="text-align:center">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
<pre><code class="cpp" style="max-height:100em" data-noescape>template&lt;typename TypeList&gt; struct DecodeAllAndApply;

<span $make_fragment("0")$>template&lt;typename... T&gt;
struct DecodeAllAndApply&lt;std::tuple&lt;T...&gt;&gt; {
<span $make_fragment("1")$>  uint32_t offset = 0x1; // offset into command block

  <span $make_fragment("2")$>// Read a single entry from the CmdBlock and advance "offset"
  template&lt;typename T&gt;
  auto DecodeEntry(CmdBlock&amp; block) { ... }</span>

  <span $make_fragment("3")$>// Iterate the entire CmdBlock, gather results and apply to "f"
  template&lt;typename F&gt;
  auto operator()(CmdBlock&amp; cmd_block, F&amp;&amp; f) {
    return f(DecodeEntry&lt;T&gt;(cmd_block)... ); <span $make_fragment("4")$>// FIXME: Execution order undefined :(</span>
  }</span></span>
};</span></code></pre>
</section>

<section><h2 style="color:$color_codegen$">Generators</h2>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center; background:#3f0000">uint32<br>5</td><td style="text-align:center">uint64_lo<br>0xdeadbeef</td><td style="text-align:center">uint64_hi<br>0x5555</td><td style="text-align:center">uint64_lo<br>0xd00f</td><td style="text-align:center">uint64_hi<br>0</td><td style="text-align:center">buffer descriptor<br>…</td><td style="text-align:center">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
Decoding 32-bit values:
<pre><code class="cpp" style="max-height:100em" data-noescape>template&lt;typename TypeList&gt; struct DecodeAllAndApply;

template&lt;typename... Ts&gt;
struct DecodeAllAndApply&lt;std::tuple&lt;Ts...&gt;&gt; {
  uint32_t offset = 0x1; // offset into command block

  // Read a single entry from the CmdBlock and advance "offset"
  template&lt;typename T&gt;
  auto DecodeEntry(CmdBlock&amp; block) {
    <span $make_fragment("0")$>if constexpr (std::is_same_v&lt;T, uint32_t&gt;) {
      <span $make_fragment("1")$>return block.ReadU32(offset<span $make_fragment("2")$>++</span>);</span>
    }</span><span $make_fragment("3")$> else {
      ...
    }</span>
  }
};</code></pre>
</section>

<section><h2 style="color:$color_codegen$">Generators</h2>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center">uint32<br>5</td><td style="text-align:center; background:#3f0000">uint64_lo<br>0xdeadbeef</td><td style="text-align:center; background:#3f0000">uint64_hi<br>0x5555</td><td style="text-align:center; background:#3f3f00">uint64_lo<br>0xd00f</td><td style="text-align:center; background:#3f3f00">uint64_hi<br>0</td><td style="text-align:center">buffer descriptor<br>…</td><td style="text-align:center">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
Decoding 64-bit values:
<pre><code class="cpp" style="max-height:100em" data-noescape>template&lt;typename... T&gt;
struct DecodeAllAndApply&lt;std::tuple&lt;Ts...&gt;&gt; {
  uint32_t offset = 0x1; // offset into command block

  template&lt;typename T&gt;
  auto DecodeEntry(CmdBlock&amp; block) {
    // ...
    <span $make_fragment("0")$>} else if constexpr (std::is_same_v&lt;T, uint64_t&gt;) {
      <span $make_fragment("1")$>uint32_t val_low  = block.ReadU32(offset++);
      uint32_t val_high = block.ReadU32(offset++);</span>
      <span $make_fragment("2")$>return (val_high << 32) | val_low;</span>
    }</span><span $make_fragment("0")$> else {
      ...
    }</span>
  }
};</code></pre>
</section>

<section><h2 style="color:$color_codegen$">Generators</h2>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center">uint32<br>5</td><td style="text-align:center">uint64_lo<br>0xdeadbeef</td><td style="text-align:center">uint64_hi<br>0x5555</td><td style="text-align:center">uint64_lo<br>0xd00f</td><td style="text-align:center">uint64_hi<br>0</td><td style="text-align:center; background:#3f0000">buffer descriptor<br>…</td><td style="text-align:center; background:#3f0000">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
Decoding buffer descriptors:
<pre><code class="cpp hljs" style="max-height:100em" data-noescape>template&lt;typename... T&gt;
struct DecodeAllAndApply&lt;std::tuple&lt;Ts...&gt;&gt; {
  uint32_t offset = 0x1; // offset into command block

  template&lt;typename T&gt;
  auto DecodeEntry(CmdBlock&amp; block) {
    // ...
    <span $make_fragment("0")$>} else if constexpr (std::is_same_v&lt;T, $cpptype_writeablebuffer$&gt;) {
      <span $make_fragment("1")$>uint32_t descriptor = block.ReadU32(offset++);
      auto [size, flags] = DecodeBufferDescriptor(descriptor);</span>
      <span $make_fragment("2")$>uint32_t address = block.ReadU32(offset++);</span>
      <span $make_fragment("3")$>return WriteableBuffer { address, size };</span>
    }</span><span $make_fragment("4")$> else {
      ...
    }</span>
  }
};</code></pre>
</section>

<section><h2 style="color:$color_codegen$">Generators:</h2>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center; background:#00003f">uint32<br>5</td><td style="text-align:center; background:#3f0000">uint64_lo<br>0xdeadbeef</td><td style="text-align:center; background:#3f0000">uint64_hi<br>0x5555</td><td style="text-align:center; background:#3f3f00">uint64_lo<br>0xd00f</td><td style="text-align:center; background:#3f3f00">uint64_hi<br>0</td><td style="text-align:center; background:#003f00">buffer descriptor<br>…</td><td style="text-align:center; background:#003f00">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
<pre><code class="cpp" style="max-height:100em" data-noescape>template&lt;typename TypeList&gt; struct DecodeAllAndApply;

template&lt;typename... T&gt;
struct DecodeAllAndApply&lt;std::tuple&lt;T...&gt;&gt; {
  uint32_t offset = 0x1; // offset into command block

  // Read a single entry from the CmdBlock and advance "offset"
  template&lt;typename T&gt;
  auto DecodeEntry(CmdBlock&amp; block) { ... }</span>

  // Iterate the entire CmdBlock, gather results and apply to "f"
  template&lt;typename F&gt;
  auto operator()(CmdBlock&amp; cmd_block, F&amp;&amp; f) {
    return f(DecodeEntry&lt;T&gt;(cmd_block)... ); <span $make_fragment("0")$>// FIXME: Execution order undefined :(</span>
  }
};</code></pre>
</section>

<section><h2 style="color:$color_codegen$">Generators:</h2>
<h2>Demo time!</h2>
</section>

<section><h2 style="color:$color_codegen$">Generators: Result encoder</h2>
  <table style="font-size:60%">
    <tr>
      <td style="text-align:center">header<br>0x8020002</td><td style="text-align:center">Result<br>0x0</td>
    </tr>
  </table>

<p>Trivial with fold expressions!</p>

<pre $make_fragment("0")$><code class="cpp">template&lt;typename TypeList&gt; struct EncodeAll;

template&lt;typename... T&gt;
struct EncodeAll&lt;std::tuple&lt;T...&gt;&gt; {
  uint32_t offset = 0x1;

  template&lt;typename T&gt;
  auto EncodeEntry(CmdBlock&amp; block) { ... }

  void operator()(CmdBlock&amp; cmd_block) {
    (EncodeEntry&lt;T&gt;(cmd_block, t), ...);
  }
};</code></pre>
</section>

<section><h2>Putting Things Together</h2>
<pre><code class="cpp">GlueCommandHandler(DoReadFile, cmd_block);</code></pre>

<pre $make_fragment("0")$><code class="cpp" data-noescape>template&lt;typename Handler&gt;
void GlueCommandHandler(Handler&amp;&amp; handler, CmdBlock&amp; cmd_block) {
  <span $make_fragment("1")$>auto request_header = cmd_block.ReadU32(0);</span></span>
  <span $make_fragment("2")$>using RequestList = typename FunctionTraits&lt;Handler&gt;::Args;</span>
  <span $make_fragment("2")$>using ResponseList = typename FunctionTraits&lt;Handler&gt;::Result;</span>
  <span $make_fragment("3")$>auto results = DecodeAllAndApply&lt;RequestList&gt;{}(cmd_block, handler);</span>
  <span $make_fragment("4")$>cmd_block.WriteU32(BuildResponseHeader(results));</span>
  <span $make_fragment("5")$>EncodeAll&lt;ResponseList&gt;{}(cmd_block, results);</span>
}</code></pre>

<p $make_fragment("6")$>Omitted for now:</p>
<ul $make_fragment("6")$>
  <li>Command header verification</li>
  <li>BuildResponseHeader</li>
</ul>
</section>
