<section><h2 style="color:#f6ba4a">Generators</h2>
<p>Core idea: Generate <span style="color:#f64a4a">runtime code</span> based on a <span style="color:#f7f749">type list</span> via</p> <!-- NB: Mention this is done via a function or function object -->
<ul>
  <li class="fragment">Recursion</li>
  <li class="fragment"><pre style="display:inline; font-size:85%">for_each(tuple, f)</pre></li> <!-- NB: e.g. via boost mpl -->
  <li class="fragment">parameter pack expansions (C++11)</li>
  <li class="fragment">fold expressions (C++17)</li>
</ul>

<p class="fragment">We got our <span style="color:#f7f749">type list</span> from the <span style="color:#30cfcf">declarative interface</span></p>
<p class="fragment">How do we <span style="color:#f6ba4a">generate</span> a command block decoder?</p>
</section>

<section><h2>A <span style="color:#f6ba4a">Generative</span> decoder</h2>
  <pre style="width:71.1%">RequestList: std::tuple&lt;uint32_t, uint64_t, uint64_t, WriteableBuffer &gt;</pre>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center">uint32<br>5</td><td style="text-align:center">uint64_lo<br>0xdeadbeef</td><td style="text-align:center">uint64_hi<br>0x5555</td><td style="text-align:center">uint64_lo<br>0xd00f</td><td style="text-align:center">uint64_hi<br>0</td><td style="text-align:center">buffer descriptor<br>â€¦</td><td style="text-align:center">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
<pre><code class="cpp" style="max-height:100em" data-noescape><span class="fragment" data-fragment-index=0>// Read a single entry from the CmdBlock and advance "offset"
template&lt;typename T&gt;
auto DecodeEntry(int& offset, CmdBlock&amp; block) { ... }</span>
<span class="fragment" data-fragment-index=1>
// Iterate over entire CmdBlock &amp; gather results <span class="fragment" data-fragment-index=4>&amp; apply to "handler"</span>
template&lt;<span class="fragment" data-fragment-index=4>typename Handler, </span>typename... Ts&gt;
auto DecodeAll<span class="fragment" data-fragment-index=4>AndApply</span>(CmdBlock&amp; cmd_block<span class="fragment" data-fragment-index=4>, Handler&amp;&amp; handler</span>) {
  <span class="fragment" data-fragment-index=2>int offset = 0x1; // into command block
  <span class="fragment" data-fragment-index=3>return <span class="fragment" data-fragment-index=4>handler(</span>DecodeEntry&lt;Ts&gt;(offset, cmd_block)...<span class="fragment" data-fragment-index=4>)</span>;
</span></span>}
</span></code></pre>
<span class="for-beginners"><p class="fragment" data-fragment-index=5><small>NB: <i>Variadic templates</i> and <i>parameter pack expansions</i> are awesome!</small></p></span>
</section>


<section data-transition="slide-in fade-out"><h2 style="color:#f6ba4a">Generators</h2>
  <pre style="width:71.1%">RequestList: std::tuple&lt;<span style="color:#f03040">uint32_t</span>, uint64_t, uint64_t, WriteableBuffer &gt;</pre>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center; background:#3f0000">uint32<br>5</td><td style="text-align:center">uint64_lo<br>0xdeadbeef</td><td style="text-align:center">uint64_hi<br>0x5555</td><td style="text-align:center">uint64_lo<br>0xd00f</td><td style="text-align:center">uint64_hi<br>0</td><td style="text-align:center">buffer descriptor<br>â€¦</td><td style="text-align:center">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
Decoding 32-bit values:
<pre><code class="cpp" style="max-height:100em" data-noescape>template&lt;typename T&gt;
auto DecodeEntry(int& offset, CmdBlock&amp; block) {
  <span class="fragment" data-fragment-index=0>if constexpr (std::is_same_v&lt;T, uint32_t&gt;) {
    <span class="fragment" data-fragment-index=1>return block.ReadU32(offset<span class="fragment" data-fragment-index=2>++</span>);</span>







  }</span><span class="fragment" data-fragment-index=3> else {
    ...
  }</span>
}
</code></pre>
</section>

<section data-transition="fade-in fade-out"><h2 style="color:#f6ba4a">Generators</h2>
  <pre style="width:71.1%">RequestList: std::tuple&lt;uint32_t, <span style="color:#f03040">uint64_t</span>, <span style="color:#f0f040">uint64_t</span>, WriteableBuffer &gt;</pre>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center">uint32<br>5</td><td style="text-align:center; background:#3f0000">uint64_lo<br>0xdeadbeef</td><td style="text-align:center; background:#3f0000">uint64_hi<br>0x5555</td><td style="text-align:center; background:#3f3f00">uint64_lo<br>0xd00f</td><td style="text-align:center; background:#3f3f00">uint64_hi<br>0</td><td style="text-align:center">buffer descriptor<br>â€¦</td><td style="text-align:center">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
Decoding 64-bit values:
<pre><code class="cpp" style="max-height:100em" data-noescape>template&lt;typename T&gt;
auto DecodeEntry(int& offset, CmdBlock&amp; block) {
  if constexpr (std::is_same_v&lt;T, uint32_t&gt;) {
    return block.ReadU32(offset++);
  <span class="fragment" data-fragment-index=0>} else if constexpr (std::is_same_v&lt;T, uint64_t&gt;) {
    <span class="fragment" data-fragment-index=1>uint32_t val_low  = block.ReadU32(offset++);
    uint32_t val_high = block.ReadU32(offset++);</span>
    <span class="fragment" data-fragment-index=2>return (val_high &lt;&lt; 32) | val_low;</span>



  </span>} else {
    ...
  }
}</code></pre>
</section>

<section data-transition="fade-in slide-out"><h2 style="color:#f6ba4a">Generators</h2>
  <pre style="width:71.1%">RequestList: std::tuple&lt;uint32_t, uint64_t, uint64_t, <span style="color:#f03040">WriteableBuffer</span> &gt;</pre>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center">uint32<br>5</td><td style="text-align:center">uint64_lo<br>0xdeadbeef</td><td style="text-align:center">uint64_hi<br>0x5555</td><td style="text-align:center">uint64_lo<br>0xd00f</td><td style="text-align:center">uint64_hi<br>0</td><td style="text-align:center; background:#3f0000">buffer descriptor<br>â€¦</td><td style="text-align:center; background:#3f0000">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
Decoding buffer descriptors:
<pre><code class="cpp hljs" style="max-height:100em" data-noescape>template&lt;typename T&gt;
auto DecodeEntry(int& offset, CmdBlock&amp; block) {
  if constexpr (std::is_same_v&lt;T, uint32_t&gt;) {
    return block.ReadU32(offset++);
  } else if constexpr (std::is_same_v&lt;T, uint64_t&gt;) {
    ...
  <span class="fragment" data-fragment-index=0>} else if constexpr (std::is_same_v&lt;T, WriteableBuffer&gt;) {
    <span class="fragment" data-fragment-index=1>uint32_t descriptor = block.ReadU32(offset++);
    auto [size, flags] = DecodeBufferDescriptor(descriptor);</span>
    <span class="fragment" data-fragment-index=2>uint32_t address = block.ReadU32(offset++);</span>
    <span class="fragment" data-fragment-index=3>return WriteableBuffer { address, size };</span>
  </span>} else {
    ...
  }
}</code></pre>
</section>

<section><h2>A <span style="color:#f6ba4a">Generative</span> decoder</h2>
  <pre style="width:71.1%">RequestList: std::tuple&lt;<span style="color:#4030f0">uint32_t</span>, <span style="color:#f03040">uint64_t</span>, <span style="color:#f0f040">uint64_t</span>, <span style="color:#30f040">WriteableBuffer</span> &gt;</pre>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center; background:#00003f">uint32<br>5</td><td style="text-align:center; background:#3f0000">uint64_lo<br>0xdeadbeef</td><td style="text-align:center; background:#3f0000">uint64_hi<br>0x5555</td><td style="text-align:center; background:#3f3f00">uint64_lo<br>0xd00f</td><td style="text-align:center; background:#3f3f00">uint64_hi<br>0</td><td style="text-align:center; background:#003f00">buffer descriptor<br>â€¦</td><td style="text-align:center; background:#003f00">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
<pre><code class="cpp" style="max-height:100em" data-noescape>// Read a single entry from the CmdBlock and advance "offset"
template&lt;typename T&gt;
auto DecodeEntry(int& offset, CmdBlock&amp; block) { ... }

// Iterate over entire CmdBlock &amp; gather results &amp; apply to "handler"
template&lt;typename Handler, typename... Ts&gt;
auto DecodeAllAndApply(CmdBlock&amp; cmd_block, Handler&amp;&amp; handler) {
  int offset = 0x1; // into command block
  return handler(DecodeEntry&lt;Ts&gt;(offset, cmd_block)...);
}
</code></pre>
<p class="fragment" data-fragment-index=0>No boilerplate!</p>
<p class="fragment" data-fragment-index=1>Caveat 1: The template needs a std::tuple&lt;T...&gt; &nbsp;ðŸ˜”</p>
</section>

<section><h2 style="color:#f6ba4a">Generators:</h2>
  <pre style="width:71.1%">RequestList: std::tuple&lt;<span style="color:#4030f0">uint32_t</span>, <span style="color:#f03040">uint64_t</span>, <span style="color:#f0f040">uint64_t</span>, <span style="color:#30f040">WriteableBuffer</span> &gt;</pre>
  <table style="font-size:50%" align="center">
    <tr>
      <td style="text-align:center">header<br>0x8020205</td><td style="text-align:center; background:#00003f">uint32<br>5</td><td style="text-align:center; background:#3f0000">uint64_lo<br>0xdeadbeef</td><td style="text-align:center; background:#3f0000">uint64_hi<br>0x5555</td><td style="text-align:center; background:#3f3f00">uint64_lo<br>0xd00f</td><td style="text-align:center; background:#3f3f00">uint64_hi<br>0</td><td style="text-align:center; background:#003f00">buffer descriptor<br>â€¦</td><td style="text-align:center; background:#003f00">buffer addr<br>0x1ff00200</td>
    </tr>
  </table>
<pre><code class="cpp" style="max-height:100em" data-noescape>// Read a single entry from the CmdBlock and advance "offset"
template&lt;typename T&gt;
auto DecodeEntry(int& offset, CmdBlock&amp; block) { ... }

template&lt;typename TypeList&gt; struct DecodeAllAndApply;

template&lt;typename... Ts&gt;
struct DecodeAllAndApply&lt;std::tuple&lt;Ts...&gt;&gt; {
  int offset = 1; // offset into command block

  // Iterate over entire CmdBlock &amp; gather results &amp; apply to "handler"
  template&lt;typename Handler&gt;
  auto operator()(CmdBlock&amp; cmd_block, Handler&amp;&amp; handler) {
    <span class="fragment" data-fragment-index=0>// Caveat 2: Execution order undefined :(</span>
    return handler(DecodeEntry&lt;Ts&gt;(offset, cmd_block)...);
  }
};</code></pre>
</section>

<section><h2 style="color:#f6ba4a">Generators:</h2>
<h2>Demo time!</h2>
<p><a href=https://github.com/neobrain/presentations/blob/TODO/live/01a_generators.cpp>01a_generators.cpp</a><br>
<a href=https://github.com/neobrain/presentations/blob/TODO/live/01b_generators.cpp>01b_generators.cpp</a><br>
<a href=https://github.com/neobrain/presentations/blob/TODO/live/magic.hpp>magic.hpp</a></p>
</section>

<section><h2 style="color:#f6ba4a">Generators: Result encoder</h2>
  <table style="font-size:60%">
    <tr>
      <td style="text-align:center">header<br>0x8020002</td><td style="text-align:center">Result<br>0x0</td><td style="text-align:center">uint32_t<br>0xd00f</td>
    </tr>
  </table>

<p>Trivial with fold expressions!</p>

<pre class="fragment" data-fragment-index=0><code class="cpp" data-noescape>template&lt;typename T&gt;
void EncodeEntry(int& offset, CmdBlock&amp; block, T t) { ... }

<span class="fragment">template&lt;typename... Ts&gt;
void EncodeAll(CmdBlock&amp; cmd_block, Ts... ts) {
  int offset = 1;

  <span class="fragment">(EncodeEntry&lt;T&gt;(offset, cmd_block, ts), ...);</span>
}</span></code></pre>
</section>

<!-- <section><h2>Putting Things Together</h2>
<pre><code class="cpp" data-noescape><span class="fragment" data-fragment-index=8>GlueCommandHandler(DoOpenFile, cmd_block);</span>
GlueCommandHandler(DoReadFile, cmd_block);
<span class="fragment" data-fragment-index=8>GlueCommandHandler(DoCloseFile, cmd_block);</span></code></pre>

<pre class="fragment" data-fragment-index=0><code class="cpp" data-noescape>template&lt;typename Handler&gt;
void GlueCommandHandler(Handler&amp;&amp; handler, CmdBlock&amp; cmd_block) {
  <span class="fragment" data-fragment-index=1>auto request_header = cmd_block.ReadU32(0);</span></span>
  <span class="fragment" data-fragment-index=2>using RequestList = typename FunctionTraits&lt;Handler&gt;::Args;</span>
  <span class="fragment" data-fragment-index=2>using ResponseList = typename FunctionTraits&lt;Handler&gt;::Result;</span>
  <span class="fragment" data-fragment-index=3>auto results = DecodeAllAndApply&lt;RequestList&gt;{}(cmd_block, handler);</span>
  <span class="fragment" data-fragment-index=4>cmd_block.WriteU32(BuildResponseHeader(results));</span>
  <span class="fragment" data-fragment-index=5>EncodeAll&lt;ResponseList&gt;{}(cmd_block, results);</span>
}</code></pre>

<p class="fragment" data-fragment-index=6>Omitted for now:</p>
<ul class="fragment" data-fragment-index=6>
  <li>Command header verification</li>
  <li>BuildResponseHeader</li>
</ul>
<p class="fragment" data-fragment-index=7>But: This can be used for all IPC commands!</p>
</section>
-->

