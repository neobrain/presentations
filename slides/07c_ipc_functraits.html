<section><h2 style="color:#49f749">Function Traits</h2>
<ul>
<!--  <li class="fragment" data-fragment-index=0>Type traits: Get info about a type at compile-time</li> -->
  <li class="fragment" data-fragment-index=3>Function traits:
  <ul>
  <li>Type traits for functions</li>
  <li class="fragment" data-fragment-index=4>Get parameter list &amp; return type</li>
  </ul>
</ul>
<span class="fragment">
<pre><code class="cpp">template&lt;typename F&gt;
struct FunctionTraits {
  using Args   = std::tuple&lt; /* Parameter list of F */ &gt;;
  using Result = /* Return type of F */;
};
</code></pre>
</span>
<span class="fragment">
<p>Implementations available in</p>
<ul>
  <li>Boost.FunctionTypes (C++98?)</li>
  <li>Boost.CallableTraits (C++11)<br><small class="footer">Standalone: https://github.com/badair/callable_traits</small></li>
</ul>
</span>
</section>


<section><h2 style="color:#49f749">Function Traits</h2>
<p>Minimal implementation</p>
<span class="fragment" data-fragment-index=0>
<pre><code class="cpp" data-noescape>template&lt;typename F&gt;
struct FunctionTraits;

// (Partial) specialization for free functions
template&lt;typename FuncResult, typename... FuncArgs&gt;
struct FunctionTraits&lt;Result(Args...)&gt; {
  using Args   = std::tuple&lt;FuncArgs...&gt;;
  using Result = FuncResult;<span class="fragment" data-fragment-index=1> // NB: This will be some tuple&lt;&gt; for us</span>
};
</code></pre>
Very limited, but good enough here
</span>
<p class="fragment"><small>NB: "using" is C++11-syntax for type aliases ("typedef")</small></p>
</section>

