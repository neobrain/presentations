<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Generative Programming in Action: Emulating the 3DS</title>

    <style>
      .comment { color: #bbb; font-size: 22pt !important; }
      .fixed { color: purple; font-size: 13pt !important; }
      table, td, th { border: 3px solid #b0b0b0 !important; border-collapse: collapse !important; border-radius:5px !important; }
      img { border-radius:10px; }
      .main_cpu { border-color: #FFA500 !important; border-collapse: separate !important; }
      .chip { display: inline; border-color: #D8BFD8 !important; border-collapse: separate !important; }
      .chip td { border-width: 0 !important; }
      .chip tr { border-width: 0 !important; }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- <div class="share-reveal" style="display: block; position: absolute; top: -8pt; right:0pt; z-index: 20; font-size:50%; color:#808080; white-space:nowrap">
          neobrain.github.io | <span style="font-family: 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif">@</span>fail_cluez
        </div> -->

<section><h2>Generative Programming in Action</h2><h3>Emulating the Nintendo 3DS</h3>
<div style="display:flex; justify-content:space-around">
<p style="width:25%; font-size:80%; color:#c0c0c0">Tony Wasserka<br><small>@fail_cluez</small></p>
<p style="width:25%; font-size:80%; color:#c0c0c0">C++::London<br><small>19 Feb 2018</small></p>
</div>
</section>

<section><h2>What this will be about</h2>
<ul>
<li class="fragment" data-fragment-index="0">Introduction to the 3DS kernel interface</li>
<li class="fragment" data-fragment-index="1">Claim: Metaprogramming is useful here</li> <!-- + language evolution has made it more accessible -->
<ul>
<li class="fragment" data-fragment-index="2">It's more accessible than ever!</li>
</ul>
<li class="fragment" data-fragment-index="3">Show off some common techniques</li> <!-- Stress that this is not a tutorial: "Focus on what can be done rather than how!" -->
</ul>

<p class="fragment" data-fragment-index="4">First of all: Who am I?</p>
</section>

<section><h2>Who am I?</h2>
<ul>
<li>C++ enthusiast: Low-level &amp; type-safety</li> <!-- C++ makes the type system effective even for inherently untyped data -->
<li>Game console emulation: GC/Wii/3DS/PSP</li>
<div style="display:flex; justify-content:space-around; align-items:center">
<small style="text-align: center"><img src="images/ppsspp_logo.svg" height="100em" style="border:none; background-color: transparent; box-shadow: none; vertical-align:middle"><br>PPSSPP</small>
<small style="text-align: center"><img src="images/dolphin_logo.svg" height="150em" style="border:none; background-color: transparent; box-shadow: none; vertical-align:middle"><br>Dolphin</small>
<small style="text-align: center"><img src="images/citra_logo.svg" height="100em" style="border:none; background-color: transparent; box-shadow: none; vertical-align:middle"><br>Citra</small><br>
</div>
<li>Twitter: @fail_cluez, GitHub: neobrain <img src="images/glitchedcube2.png" height="100em" style="border-radius:20px; vertical-align:middle"></li>
<li>Studied Physics, now working on GPU drivers</li>
</ul>
</section>

<section><h2>The Nintendo 3DS</h2>
<div style="display:flex; justify-direction:column">
<img src="images/3ds.png" height="250em" style="border:none; background-color: transparent; box-shadow: none; vertical-align:middle">
<ul>
<li>Released in 2011</li>
<li class="fragment" data-fragment-index="0">CPU: 2x ARM11 MPCore @ 268 MHz</li> <!-- "Big embedded system" -->
<li class="fragment" data-fragment-index="0">GPU: DMP PICA200</li>
<li class="fragment" data-fragment-index="0">RAM: 128 MB FCRAM, 6 MB VRAM</li>
<li class="fragment" data-fragment-index="1">Software stack:
<ul class="fragment" data-fragment-index="1">
<li>Microkernel (fully multitasking)</li>
<li>Microservices</li>
</ul>
</ul>
</div>
</section>

<section><h2>The 3DS Software Stack</h2> <!-- Three layers that are relevant to emulation -->
<div style="display:flex; justify-direction:column">
<img src="images/3ds.png" height="250em" style="border:none; background-color: transparent; box-shadow: none; vertical-align:middle">
<table width="65%">
            <tr>
              <td class="fragment fade-in" data-fragment-index="2" colspan="6">
                <div style="display:flex; align-items:center; justify-content:space-between">
                  <div><font color="#40c030">Game/Application</font></div>
                  <div class="comment" style="font-size:17pt !important; text-align:right">Runs on emulated CPU</div>
                </div>
              </td>
            </tr>
            <tr>
              <td class="fragment fade-in" data-fragment-index="1" colspan="6">
                <div style="display:flex; align-items:center; justify-content:space-between">
                  <font color="#e06130">Kernel: Horizon</font>
                  <div class="comment">API emulation</div>
                </div>
              </td>
            </tr>
            <tr>
              <td class="fragment fade-in" data-fragment-index="0" colspan="6">
                <div style="display:flex; align-items:center; justify-content:space-between">
                   <font color="#d02030">ARM11 CPUs</font>
                   <div class="comment">Interpreter</div>
                </div>
              </td>
            </tr>
</table>
</div>
</section>

<section><h2>3DS System Calls</h2>
<p>Kernel↔Application interface: 130 system calls</p>
<ul>
<li class="fragment" data-fragment-index="0">Memory management</li>
<li class="fragment" data-fragment-index="1">Multi-Processing/Threading</li>
<li class="fragment" data-fragment-index="2">Synchronisation</li>
<li class="fragment" data-fragment-index="3">Inter-Process Communication</li>
<li class="fragment" data-fragment-index="4">…</li>
</ul>
</section>

<section data-transition="slide-in fade-out"><h2>3DS System Calls</h2>
<p>System calls on hardware:</p>

<div style="display:flex; justify-content:space-around; align-items:center">
<img src="images/asm_svc_example.png" style="vertical-align:middle">
<div class="fragment" data-fragment-index="0">⟶</div>
<div style="display:inline-block; text-align:center; vertical-align:middle" class="fragment" data-fragment-index="0"><ul><li>CPU software interrupt</li><li>Mode switch (to kernel)</li><li>OS interrupt handler</li><li>Mode switch (to userland)</li></ul></div>
</div>
<!-- Stress how SVCs read and write back from/to CPU registers to get arguments/return results -->
<pre style="visibility:hidden"><code class="cpp">struct CPUContext {
  uint32_t reg[16];
} cpu;
</code></pre>
</section>


<section data-transition="fade-in slide-out"><h2>3DS System Calls</h2>
<p>High-level emulation:</p>

<div style="display:flex; justify-content:space-around; align-items:center">
<img src="images/asm_svc_example.png" style="vertical-align:middle">
<div>⟶</div>
<div style="display:inline-block; text-align:center; vertical-align:middle">HandleSVC(cpu, 0x54);</div>
</div>
<pre><code class="cpp">struct CPUContext {
  uint32_t reg[16];
} cpu;
</code></pre>
</section>

<section data-transition="slide-in fade-out"><h2>Emulating 3DS System Calls</h2>
Example handlers:<br>
<span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="0"><span class="fragment fade-out" data-fragment-index="1"><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em; overflow:hidden"><!--
--><!--
-->// No inputs, no outputs
void
DoExitProcess();<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::ExitCurrentProcess: // 0x3
    DoExitCurrentProcess();
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="1"><span class="fragment fade-out" data-fragment-index="2"><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em; overflow:hidden"><!--
--><!--
-->// One input, one output
uint32_t <!-- NOTE: Will return std::tuple<u32> later, but for now a plain u32 is better to convey the idea -->
DoSleepThread(uint32_t duration);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::SleepThread: // 0xa
    uint32_t duration_ns = FromRegister&lt;uint32_t&gt;(cpu.reg[0]);

    auto result = DoSleepThread(duration_ns);

    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(result); // result code
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3"><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em; overflow:hidden"><!--
--><!--
-->// Three inputs, two outputs
std::tuple&lt;uint32_t, VAddr&gt;
DoControlMemory(uint32_t size, uint32_t perm, uint32_t mode);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::ControlMemory: // 0x1
    uint32_t size        = FromRegister&lt;uint32_t&gt;(cpu.reg[1]); 
    uint32_t mode        = FromRegister&lt;uint32_t&gt;(cpu.reg[2]);
    uint32_t permissions = FromRegister&lt;uint32_t&gt;(cpu.reg[3]);
    auto outputs = DoControlMemory(size, permissions, mode);
    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(std::get&lt;0&gt;(outputs)); // Error code
    cpu.reg[1] = ToRegister&lt;VAddr   &gt;(std::get&lt;1&gt;(outputs)); // Block address
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="3"><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em; overflow:hidden"><!--
--><!--
-->// Three inputs, two outputs
std::tuple&lt;uint32_t, VAddr&gt;
DoControlMemory(uint32_t size, uint32_t perm, uint32_t mode);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::ControlMemory: // 0x1
    uint32_t size        = FromRegister&lt;uint32_t&gt;(cpu.reg[1]); <font color="red">/​/ Starts at r1??</font>
    uint32_t mode        = FromRegister&lt;uint32_t&gt;(cpu.reg[2]);
    uint32_t permissions = FromRegister&lt;uint32_t&gt;(cpu.reg[3]);
    auto outputs = DoControlMemory(size, permissions, mode);
    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(std::get&lt;0&gt;(outputs)); // Error code
    cpu.reg[1] = ToRegister&lt;VAddr   &gt;(std::get&lt;1&gt;(outputs)); // Block address
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span>
</section>


<section data-transition="fade-in slide-out"><h2>Emulating 3DS System Calls</h2>
<!-- Showing the CreateMutex and LockMutex handlers, now that the kernel objects have been introduced -->
Example handlers:<br>
<span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="0"><span class="fragment fade-out" data-fragment-index="1"><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em"><!--
--><!--
-->// No inputs, two outputs
std::tuple&lt;Result, Mutex*&gt;
DoCreateMutex();<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::CreateMutex: // 0x13
    auto outputs = DoCreateMutex();
    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(std::get&lt;0&gt;(outputs)); // Error code
    cpu.reg[1] = ToRegister&lt;Mutex*  &gt;(std::get&lt;1&gt;(outputs)); // Handle of created mutex
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="1"><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em"><!--
--><!--
-->// One input, one output
Result
DoLockMutex(Mutex* mutex, uint32_t timeout);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::LockMutex: // 0x24
    Mutex*   mutex   = FromRegister&lt;Mutex*  &gt;(cpu.reg[0]);
    uint32_t timeout = FromRegister&lt;uint32_t&gt;(cpu.reg[1]);
    auto output = DoLockMutex(mutex, timeout);
    cpu.reg[0] = ToRegister&lt;uint32_t&gt;(output);
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span>
</section>


<section><h2>Emulating 3DS System Calls</h2>
Common structure:
<ul>
<li class="fragment" data-fragment-index="0">Read inputs from CPU registers (cpu.reg[n])</li>
<ul><li class="fragment" data-fragment-index="1">Handle→Object* lookup via <span style=" vertical-align: baseline; font-family: monospace; font-size:60%">FromReg&lt;Object*&gt;(handle)</span></li></ul>
<li class="fragment" data-fragment-index="2">Invoke main handler: <span style="font-size:60%"><span style=" vertical-align: baseline; font-family: monospace">DoCreateMutex</span>, <span style=" vertical-align: baseline; font-family: monospace">DoLockMutex</span>,…</span></li>
<li class="fragment" data-fragment-index="3">Write outputs back to CPU registers</li>
<ul><li class="fragment" data-fragment-index="4">Object*⟶Handle via <span style=" vertical-align: baseline; font-family: monospace; font-size:60%">ToRegister&lt;Object*&gt;(object)</span></li></ul>
</ul>
</section>


<section><h2>Repetitive logic makes code ...</h2>
<ul style="margin-top:-20px">
<li class="fragment" data-fragment-index="0" style="line-height:1.1">Hard to write<br><small>more typing, mental arithmetic</small></li>
<li class="fragment" data-fragment-index="1" style="line-height:1.1">Hard to modify<br><small>consistency<!-- across instances-->? <!-- no compile-time consistency checking!--> </small></li>
<li class="fragment" data-fragment-index="2" style="line-height:1.1">Hard to document<br><small><!--discoverability: -->where to put docstrings?</small></li>
<li class="fragment" data-fragment-index="3" style="line-height:1.1">Hard to understand<br><small><!--hard to reason about -->scattered information<br>magic numbers<!-- are bad--></small></li>
<li class="fragment" data-fragment-index="4" style="line-height:1.1">Hard to review &amp; validate<br><small>"given enough eyeballs" notwithstanding</small></li> <!-- "given enough eyeballs, all bugs are shallow" not so much -->
</ul>

<p><b class="fragment" data-fragment-index="5">Don't Repeat Yourself</b><br>
<span class="fragment" data-fragment-index="6">But how?</span></p>
</section>


<section><h2>Enter Compile-time Programming</h2>
<p>Building blocks:</p>
<ul>
<li class="fragment" data-fragment-index="1"><font color="#f6ba4a">Code generation</font>: <font color="#f7f749">Type lists</font> ⟶ <font color="#f64a4a">Runtime logic</font></li>
<li class="fragment" data-fragment-index="2"><font color="#49f749">Reflection</font>: Capture <font color="#0049f7">code properties</font> in <font color="#f7f749">type lists</font></li>
<li class="fragment" data-fragment-index="3"><font color="#f7f749">TMP</font>: Transform <font color="#f7f749">type list</font> into <font color="#f7f749">type lists</font></li>
</ul>

<img class="fragment" data-fragment-index="0" src="images/metaprogramming.svg" style="background:#2a2a2a">
</section>


<section><h2>Our Vision</h2>
<!-- Showing the DoStartDma handler -->
"Worst case" handler:<br>
<span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="2"><!-- Separation of Concerns: Decoding logic separate from core logic -->
<pre style="width:105%"><code class="cpp" data-trim data-noescape style="padding-bottom:0; height:21em; max-height:21em"><!--
--><!--
-->// Three inputs, two outputs
std::tuple&lt;uint32_t, DmaTracker*&gt;
DoStartDma(Process* dst_process, VAddr dst_addr,
           Process* src_proces, VAddr src_addr, uint32_t size);<!--
-->

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
<!--
-->  case SvcId::StartDma: // 0x1
    Process* dst_proc  = FromRegister&lt;Process*&gt;(cpu.reg[1]); 
    VAddr    dst_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[2]);
    Process* src_proc  = FromRegister&lt;Process*&gt;(cpu.reg[3]);
    VAddr    src_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[0]); 
    uint32_t data_size = FromRegister&lt;uint32_t&gt;(cpu.reg[4]); 
    auto outputs = DoStartDma(dst_proc, dst_addr, src_proc, src_addr, data_size);
    cpu.reg[0] = ToRegister&lt;uint32_t  &gt;(std::get&lt;0&gt;(outputs)); // Error code
    cpu.reg[1] = ToRegister&lt;DmaObject*&gt;(std::get&lt;1&gt;(outputs)); // DMA object
    break;<!--
-->
  // ...
  }
}</code></pre>
</span></span>
</section>


<section style="line-height:0.5"><h2>Our Vision</h2>
<pre style="width:100%"><code class="cpp">std::tuple&lt;Result, DmaObject*&gt;
DoStartDma(Process* dst_process, VAddr dst_data_addr,
           Process* src_process, VAddr src_data_addr,
           uint32_t data_size);
</code></pre>
<span class="fragment">
↓ <font color="#49f749">Function Traits</font> ↓
<pre style="width:100%"><code class="cpp">using InData  = std::tuple&lt;Process*, VAddr, Process*, VAddr, uint32_t>
using OutData = std::tuple&lt;Result, DmaObject*>
</code></pre>
<span class="fragment">
↓ <font color="#f6ba4a">Generators</font> ↓
<pre style="width:100%"><code class="cpp">template&lt;typename  InData&gt; InData Decode(CPU&amp; cpu)
template&lt;typename OutData&gt; void   Encode(CPU&amp; cpu, OutData... data)
</code></pre>
<span class="fragment">
↓ <font color="#f7f749">Combine</font> ↓
<pre style="width:100%"><code class="cpp">case SvcId::StartDma:
  WrapSVCImpl&lt;DoStartDma&gt;(cpu);
  break;
</code></pre>
</span>
</span>
</span>
</section>


<section><h2>Our Vision</h2>
What we end up with:
<pre><code class="cpp" data-trim data-noescape style="max-height:200em"><!--
-->std::tuple&lt;uint32_t, DmaTracker*&gt;
DoStartDma(Process* dst_process, VAddr dst_addr,
           Process* src_process, VAddr src_addr, uint32_t size)

void HandleSVC(CPUContext& cpu, uint32_t index) {
  switch (index) {
  // ...
  case SvcId::StartDma:
    WrapSVCImpl&lt;DoStartDma&gt;(cpu);
    break;
  // ...
  }
}
</code></pre>

</section>

<section><h1>Our Toolbox</h1>
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
<span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="0"><span class="fragment fade-out" data-fragment-index="1"><pre><code class="cpp">template&lt;typename F, typename T&gt;
T TransformOne(F func, T value) {
  return func(value);
}
</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="1"><pre><code class="cpp">template&lt;typename F, typename T1, typename T2&gt;
std::tuple&lt;T1, T2&gt; TransformTwo(F func, T1 value1, T2 value2) {
  return std::tuple&lt;T1, T2&gt; { func(value1), func(value2) };
}
</code></pre>
</span></span>
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
<p class="fragment" data-fragment-index="0">Can take any number of arguments</p>
<p class="fragment" data-fragment-index="1">Implementation using <i>parameter pack expansion</i></p>
<div><span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="2"><span class="fragment fade-out" data-fragment-index="3"><pre><code class="cpp">template&lt;typename F, typename... T&gt;
std::tuple&lt;T...&gt; TransformMany(F func, T... values) {
  
}
</code></pre>
</span></span><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="3"><pre><code class="cpp">template&lt;typename F, typename... T&gt;
std::tuple&lt;T...&gt; TransformMany(F func, T... values) {
  return std::tuple&lt;T...&gt; { func(values) ... };
}
</code></pre>
</span></span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p class="fragment" data-fragment-index="4">TransformMany&lt;T1&gt; == TransformOne&lt;T1&gt;</p>
<p class="fragment" data-fragment-index="5">TransformMany&lt;T1, T2&gt; == TransformTwo&lt;T1, T2&gt;</p>
</section>


<section><h2 style="color:#f7f749">Tuples and Functions</h2>
std::tuple(num, str) ⇒ func(num, str) ?
<ul>
<li class="fragment" data-fragment-index="0">std::apply: Call function with tuple elements</li>
</ul>
<pre class="fragment" data-fragment-index="1"><code class="cpp">void PrintNumberAndString(int num, const char* str) {
  std::cout &lt;&lt; "Number: " &lt;&lt; num &lt;&lt; std::endl;
  std::cout &lt;&lt; "String: " &lt;&lt; str &lt;&lt; std::endl;
}

auto tuple = std::make_tuple(5, "Hello World");
std::apply(PrintNumberAndString, tup);
</code></pre>
<pre style="background:#121212" class="fragment" data-fragment-index="2">
Number: 5
String: Hello World
</pre>
</section>


<section data-transition="slide-in fade-out"><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">template&lt;typename... T&gt;
std::tuple&lt;T...&gt; Decode(CPUContext&amp; cpu) {
  unsigned reg_index = 0;
  return                    FromRegister&lt;T&gt;(cpu.reg[reg_index++])      ;
}
</code></pre>
<pre style="width:100%;visibility:hidden"><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
</section>


<section data-transition="slide-out fade-in"><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">template&lt;typename... T&gt;
std::tuple&lt;T...&gt; Decode(CPUContext&amp; cpu) {
  unsigned reg_index = 0;
  return std::tuple&lt;T...&gt; { FromRegister&lt;T&gt;(cpu.reg[reg_index++]) ... };
}
</code></pre>
<pre style="width:100%" class="fragment" data-fragment-index="0"><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
</section>


<section><h2 style="color:#f6ba4a">Variadic Templates</h2>
Smart register decoding:

<pre style="width:100%"><code class="cpp">  case SvcId::StartDma:
    auto inputs  = Decode&lt;Process*,Vaddr,Process*,VAddr,uint32_t&gt;(cpu);
    auto outputs = std::apply(DoStartDma, inputs);
</code></pre>
<p class="fragment" data-fragment-index="0">vs.</p>
<pre style="width:100%" class="fragment" data-fragment-index="0"><code class="cpp">  case SvcId::StartDma:
    auto dst_proc  = FromRegister&lt;Process*&gt;(cpu.reg[1]);
    auto dst_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[2]);
    auto src_proc  = FromRegister&lt;Process*&gt;(cpu.reg[3]);
    auto src_addr  = FromRegister&lt;VAddr   &gt;(cpu.reg[0]);
    auto data_size = FromRegister&lt;uint32_t&gt;(cpu.reg[4]);
    DoStartDma(dst_proc, dst_addr, src_proc, src_addr, data_size);
</code></pre>
</section>


<section><h2 style="color:#f6ba4a">Fold Expressions</h2>
<p>Pack expansion while applying an operator</p>
<p class="fragment" data-fragment-index="0" style="margin-bottom:0">Syntax:</p>
<div class="fragment" data-fragment-index="1"><span style="position:relative"><span class="fragment fade-in" style="position:absolute; width:1000px; transform:translate(-50%, 0%)" data-fragment-index="1"><pre><code class="cpp">template&lt;typename F, typename... T&gt;
auto AccumulateMany(F func, T... values) {
  return (func(values) + ... );
}
</code></pre>
</span></span></div><p>&nbsp;</p><p>&nbsp;</p>
<div><pre class="fragment" data-fragment-index="2"><code class="cpp">AccumulateMany(twice, 5)     == twice(5)
AccumulateMany(twice, 5, 64) == twice(5)+twice(64)
</code></pre></div>
<ul>
<li class="fragment" data-fragment-index="3">All binary operators supported …</li>
<li class="fragment" data-fragment-index="4">… including the comma operator</li> <!-- Guess which one we'll fold over -->
</ul>
</section>


<section><h2 style="color:#f6ba4a">Fold Expressions</h2>
Smart register encoding:
<ul>
  <li>
  Sequentially apply this function on each input type:
  <pre style="width:100%"><code class="cpp">cpu->reg[reg_index++] = ToRegister&lt;T&gt;(t)</code></pre>
  </li>
  <li class="fragment" data-fragment-index="2">Fold expression using comma!
<pre style="width:100%" class="fragment" data-fragment-index="2"><code class="cpp" style="padding-bottom:0">template&lt;typename... T&gt;
void Encode(const T&amp;... values) {
  unsigned reg_index = 0;
  ((cpu.reg[reg_index++] = ToRegister&lt;T&gt;(values)), ...);
}
</code></pre>
</li>
<li class="fragment" data-fragment-index="3">
<pre style="width:100%" class="fragment" data-fragment-index="2"><code class="cpp" style="padding-bottom:0">auto outputs = std::apply(DoStartDma, inputs);
std::apply(Encode&lt;uint32_t,DmaObject*&gt;, outputs);
</code></pre>
  </li>
</ul>
</section>


<section><h2 style="color:#49f749">Function traits</h2>
<ul>
<li class="fragment" data-fragment-index="0">Type traits: Get info about a type at compile-time</li>
<li class="fragment" data-fragment-index="1">E.g: std::is_pointer, std::is_copy_constructible, …</li>
<li class="fragment" data-fragment-index="2">Structure in pseudo-code:</li>
<div class="fragment" data-fragment-index="2" style="display:flex">
<pre><code class="cpp">struct is_pointer&lt;int*&gt; {
  bool value = true;
};
</code></pre>
<p style="width:10%">&nbsp;</p>
<pre><code class="cpp">struct is_pointer&lt;int&gt; {
  bool value = false;
};
</code></pre>
<p style="width:50%">&nbsp;</p>
</div>
<li class="fragment" data-fragment-index="3">Function traits:
<ul>
<li>Type traits for functions</li>
<li class="fragment" data-fragment-index="4">Get parameter list &amp; return type</li>
</ul>
</ul>
<br>
</section>


<section><h2 style="color:#49f749">Function Traits</h2>
<span class="fragment">
<pre style="width:100%"><code class="cpp">template&lt;typename F&gt;
struct FunctionTraits {
  using Args   = std::tuple&lt; /* Parameter list of F */ &gt;;
  using Result = /* Return type of F */;
};
</code></pre>
</span>
<span class="fragment">
<p>Implementations available in</p>
<ul>
  <li>Boost.FunctionTypes (C++98?)</li>
  <li>Boost.CallableTraits (C++11)<br><small class="footer">Standalone: https://github.com/badair/callable_traits</small></li>
</ul>
</span>
</section>


<section><h2 style="color:#49f749">Function Traits</h2>
<p>Minimal implementation for our use case</p>
<span class="fragment">
<pre style="width:100%"><code class="cpp">template&lt;typename F&gt;
struct FunctionTraits;

// Specialisation
template&lt;typename FuncResult, typename... FuncArgs&gt;
struct FunctionTraits&lt;Result(Args...)&gt; {
  using Args   = std::tuple&lt;FuncArgs...&gt;;
  using Result = FuncResult;
};
</code></pre>
Very limited, but good enough here
</span>
</section>

<section style="line-height:0.5"><h2>Our Vision</h2>
<pre style="width:100%"><code class="cpp">std::tuple&lt;Result, DmaObject*&gt;
DoStartDma(Process* dst_process, VAddr dst_data_addr,
           Process* src_process, VAddr src_data_addr,
           uint32_t data_size);
</code></pre>
<span class="fragment">
↓ <font color="#49f749">Function Traits</font> ↓
<pre style="width:100%"><code class="cpp">using InData  = FunctionTraits&lt;decltype(DoStartDma)&gt;::Args;
using OutData = FunctionTraits&lt;decltype(DoStartDma)&gt;::Result;
</code></pre>
<span class="fragment">
↓ <font color="#f6ba4a">Generators</font> ↓
<pre style="width:100%"><code class="cpp">InData Decode&lt;InData&gt;(CPU&amp; cpu)
void   Encode&lt;OutData&gt;(CPU&amp; cpu, OutData... data)
</code></pre>
<span class="fragment">
↓ <font color="#f7f749">Combine</font> ↓
<pre style="width:100%"><code class="cpp">case SvcId::StartDma:
  WrapSVCImpl&lt;DoStartDma&gt;(cpu);
  break;
</code></pre>
</span>
</span>
</span>
</section>

<section>Putting things together<br><h1>In Practice</h1>
</section>


<section><h2>In Practice — Setup</h2>
Dummy environment<br>Types:
<pre style="width:100%"><code class="cpp">struct CPU {
  uint32_t reg[16];
};

// Dummy kernel object types
struct Process {};
struct DmaObject {};

using VAddr = uint32_t;
</code></pre>
</section>

<section><h2>In Practice — Setup</h2>
Dummy environment<br>Stub handler:
<pre style="width:100%"><code class="cpp">std::tuple&lt;uint32_t, DmaObject*&gt;
DoStartDma(Process* dst_process, VAddr dst_addr,
           Process* src_process, VAddr src_addr, uint32_t data_size) {
  std::cout &lt;&lt; /* log input arguments */ &lt;&lt; std::endl;

  // Return some unique-ish dummy values
  return std::tuple(uint32_t{src_addr * dst_addr}, new DmaObject);
}
</code></pre>
</section>

<section><h2>In Practice — Setup</h2>
Dummy environment<br>Verbose conversion from CPU registers:
<pre style="width:100%"><code class="cpp">template&lt;typename T&gt;
T FromRegister(uint32_t value) {
  std::cout &lt;&lt; "Decoding value " &lt;&lt; value &lt;&lt; '\n';

  if constexpr (!std::is_pointer_v&lt;T&gt;) {
    return static_cast&lt;T&gt;(value);
  } else {
    // Just hack together some pointer based on the given value
    return reinterpret_cast&lt;T&gt;(static_cast&lt;uintptr_t&gt;(value));
  }
}</code></pre>
</section>

<section><h2>In Practice — Setup</h2>
Dummy environment<br>Verbose conversion from CPU registers:
<pre style="width:100%"><code class="cpp">template&lt;typename T&gt;
uint32_t ToRegister(T value) {
  std::cout &lt;&lt; "Encoding value " &lt;&lt; value &lt;&lt; '\n';

  if constexpr (!std::is_pointer_v&lt;T&gt;) {
    return static_cast&lt;uint32_t&gt;(value);
  } else {
    // Just return the raw object address as a value
    return static_cast&lt;uint32_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(value));
  }
}</code></pre>
</section>

<section><h2>In Practice — Decoder</h2>
<p class="fragment" data-fragment-index="0" style="margin-top:-20px">Decode requires a parameter pack:</p>
<pre class="fragment" data-fragment-index="0" style="width:100%"><code class="cpp">template&lt;typename... Args&gt;
std::tuple&lt;Args...&gt; Decode(CPU&amp; cpu) { /* ... */ }
</code></pre>
<p class="fragment" data-fragment-index="2">… but FunctionTraits gave us a std::tuple</p>
<p class="fragment" data-fragment-index="3">Let's try partial template specialisation:</p>
<pre class="fragment" data-fragment-index="4" style="width:100%"><code class="cpp">template&lt;typename ArgsTuple&gt;
ArgsTuple Decode(CPU&amp;);

template&lt;typename... Args&gt;
std::tuple&lt;Args...&gt; Decode&lt;std::tuple&lt;Args...&gt;&gt;(CPU&amp;) {
  // ...
}
</code></pre>
<pre style="background:#121212; width:100%" class="fragment" data-fragment-index="5"><span style="color:red">error: </span>function template partial specialization is not allowed</pre>
</section>

<section><h2>In Practice — Decoder</h2>
<p>We can't partially specialise functions…</p>
<p class="fragment" data-fragment-index="0">… but we can partially specialise function objects!</p>

<pre style="width:100%" class="fragment" data-fragment-index="1"><code class="cpp">template&lt;typename ArgsTuple&gt;
struct Decoder;

template&lt;typename... Args&gt;
struct Decoder&lt;std::tuple&lt;Args...&gt;&gt; {
  static std::tuple&lt;Args...&gt; Decode(CPU&amp; cpu) {
    size_t reg_index = 0;
    return std::tuple&lt;Args... &gt; {
             FromRegister&lt;Args&gt;(cpu.reg[reg_index++])
             ...
           };
  }
};
</code></pre>
</section>

<section><h2>In Practice — Encoder</h2>
<p class="fragment" data-fragment-index="0">Similarly, the Encoder must be a function object too:</p>

<pre class="fragment" data-fragment-index="1" style="width:100%"><code class="cpp">template&lt;typename ArgsTuple&gt;
struct Encoder;

template&lt;typename... Args&gt;
struct Encoder&lt;std::tuple&lt;Args...&gt;&gt; {
  CPU&amp; cpu;

  void operator()(Args... args) {
    size_t reg_index = 0;
    ((cpu.reg[reg_index++] = ToRegister&lt;Args&gt;(args)), ...);
  }
};
</code></pre>

<pre class="fragment" data-fragment-index="3" style="width:100%"><code class="cpp">Encoder&lt;OutArgs&gt; encoder{cpu}; // construct stateful function object
std::apply(encoder, outputs);
</code></pre>
</section>


<section><h2>In Practice — The Glue</h2>
<pre style="width:100%"><code class="cpp" style="max-height:30em">template&lt;auto SVCImpl&gt;
void WrapSVCImpl(CPU&amp; cpu) {
  // Turn handler's function signature into std::tuples
  using InArgs = typename FunctionTraits&lt;decltype(SVCImpl)&gt;::InArgs;
  using OutArgs = typename FunctionTraits&lt;decltype(SVCImpl)&gt;::OutArgs;

  // Decode registers by calling stateless function object
  auto args = Decoder&lt;OutArgs, InArgs&gt;::Decode(cpu);

  // Call handler
  auto result = std::apply(SVCImpl, args);

  // Encode registers by calling stateful function object
  Encoder&lt;OutArgs&gt; encoder{cpu};
  std::apply(encoder, result);
}
</code></pre>
</section>

<section><h2>In Practice — The Result</h2>
<pre style="width:100%"><code class="cpp" style="max-height:30em">void HandleSVC(CPU&amp; cpu, uint32_t index) {
  switch (index) {
  // ...
  case 0x55:
    WrapSVCImpl&lt;DoStartDma&gt;(cpu);
    break;
  case 0x56:
    WrapSVCImpl&lt;DoStopDma&gt;(cpu);
    break;
  case 0x57:
    WrapSVCImpl&lt;GetDmaState&gt;(cpu);
    break;
  case 0x58:
    WrapSVCImpl&lt;DoRestartDma&gt;(cpu);
    break;
  // ...
  }
}
</code></pre>
</section>

<section><h2>In Practice — The Result</h2>
<pre style="width:100%"><code data-noescape class="cpp" style="max-height:30em">int main() {
  CPU cpu {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }};
  HandleSVC(cpu, 0x55);

  std::cout &lt;&lt; '\n' &lt;&lt; "CPU registers on return:" &lt;&lt; '\n';
  for (auto reg : cpu.reg)
    std::cout &lt;&lt; "0x" &lt;&lt; std::hex &lt;&lt; reg &lt;&lt; ' ';
}
</code></pre>

<p class="fragment" data-fragment-index="0"><a href="https://github.com/neobrain/presentations/blob/cpplondon_feb2018/live/live.cpp" target="_blank">Full example code online</a></p>
<p class="fragment" data-fragment-index="1">g++&ensp;–std=c++1z&ensp;example.cpp</p>
</section>


<section><h2>In Practice — The Result</h2>
  <pre style="width:100%; margin-top:-20px"><code data-noescape class="cpp" style="max-height:30em">int main() {
  CPU cpu {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }};
  HandleSVC(cpu, 0x55);

  std::cout &lt;&lt; '\n' &lt;&lt; "CPU registers on return:" &lt;&lt; '\n';
  for (auto reg : cpu.reg)
    std::cout &lt;&lt; "0x" &lt;&lt; std::hex &lt;&lt; reg &lt;&lt; ' ';
}</code></pre>

  <pre style="background:#121212; width:100%" class="fragment" data-fragment-index="1">
  Decoding value 0
  Decoding value <font color="Ultramarine Blue">1</font>
  Decoding value 2
  Decoding value <font color="Ultramarine Blue">3</font>
  Decoding value 4
  DoStartDma: dst_proc=0x0, dst_addr=1, src_proc=0x2, src_addr=3, size=4
              returning 3 and 0x240b280
  Encoding value <font color="#87cefa">3   = <font color="Ultramarine Blue">1</font> * <font color="Ultramarine Blue">3</font></font>
  Encoding value <font color="#32cd32">0x25ea280</font>

  CPU registers on return:
  <font color="#87cefa">0x3</font> <font color="#32cd32">0x25ea280</font> 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0x0 0x0 0x0 0x0 0x0 0x0
  </pre>
</section>


<section><h1>Conclusion</h1>
</section>


<section><h2>Conclusion</h2>
<ul>
  <li>Vastly simplified implementation</li>
    <ul><li>Easier to read, validate, and extend</li></ul>
  <li>Zero performance overhead</li>
  <li>Metaprogramming can be powerful <b>and</b> simple
    <ul><li>Especially in C++17</li></ul>
  </li>
<br>
</ul>

<p><b>The best code is the code you didn't have to write!</b></p>
</section>


<section><h2>Further Reading</h2>
<p><small class="fragment" data-fragment-index="0">Introduction to template metaprogramming:<br>Arthur O'Dwyer, <a href="https://www.youtube.com/watch?v=vwrXHznaYLA" target="_blank">Template Normal Programming</a></small></p>
<p><small class="fragment" data-fragment-index="1">Fold expressions in detail:<br>Vittorio Romeo, <a href="https://skillsmatter.com/skillscasts/11363-introduction-to-c-plus-plus-origami" target="_blank">Introduction to C++ origami</a></small></p>
</section>


<section><h1>THX &amp;&amp; FAQ ? OK : EOF</h1>
<div><a href="https://twitter.com/fail_cluez" target="_blank"><img src="images/Twitter_Logo_Custom.svg" height="75pt" style="vertical-align:middle; border:none; background-color:transparent; box-shadow:none"><span style="font-family: 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif">@</span>fail_cluez</a></div>
<div><a href="https://github.com/neobrain" target="_blank"><img src="images/GitHub-Mark-Custom.svg" height="38px" style="vertical-align:middle; border:none; background-color:transparent; box-shadow:none">&nbsp; neobrain</a></div>
<img src="images/glitchedcube2.png" height="100em" style="border-radius:20px; vertical-align:middle; margin-top:36px">
</section>


<section><h1>Bonus</h1>
</section>


<section><h2>Counting Registers</h2>
<p>Decode() was cheating before:</p>

<pre style="width:100%; margin-top:-20px"><code data-noescape class="cpp" style="max-height:30em">size_t reg_index = 0;
return std::tuple&lt;Args... &gt; {
           FromRegister&lt;Args&gt;(cpu.reg[<span style="color:#e00">reg_index++</span>]) ...
       };
</code></pre>

<p class="fragment" data-fragment-index="0">This doesn't reflect the proper register order:</p>
<p class="fragment" data-fragment-index="0">r1 → r2 → r3 → r0 → r4</p>
<p class="fragment" data-fragment-index="1">Luckily, we can just replace reg_index++ with</p>
<pre class="fragment" data-fragment-index="1" style="width:100%"><code data-noescape class="cpp" style="max-height:30em">template&lt;size_t first_reg&gt;
size_t GetAndThenUpdateRegIndex(size_t&amp; cur_index);
</code></pre>
</section>


<section><h2>Counting Registers</h2>
<p class="fragment" data-fragment-index="0">Ad-hoc logic to reproduce the 3DS register order:</p>
<pre class="fragment" data-fragment-index="1" style="width:100%"><code data-noescape class="cpp" style="max-height:30em">template&lt;size_t first_reg&gt;
size_t GetAndThenUpdateRegIndex(size_t&amp; cur_index) {
  size_t old_index = cur_index;
  ++cur_index;
  if (cur_index == 4) cur_index = 0;
  if (cur_index == first_reg) cur_index = 4;
  return old_index;
}
</code></pre>
<pre class="fragment" data-fragment-index="1" style="width:100%"><code data-noescape class="cpp" style="max-height:30em">constexpr size_t first_reg = std::tuple_size_v&lt;OutData&gt; - 1;
</code></pre>
<ul>
<li class="fragment" data-fragment-index="2" style="font-size:90%">Gets current index &amp; then advances cur_index inplace</li>
<li class="fragment" data-fragment-index="4" style="font-size:90%">first_reg is determined by the number of output values</li>
</ul>
</section>


<section><h2>Counting Registers</h2>
<pre style="width:100%" class="fragment" data-fragment-index="1"><code class="cpp">template&lt;typename OutData, typename... Args&gt;
static std::tuple&lt;Args...&gt; Decode(CPU&amp; cpu) {
  constexpr size_t first_reg = std::tuple_size_v&lt;OutData&gt; - 1;
  size_t reg_index = first_reg;
  return std::tuple&lt;Args... &gt; {
             FromRegister&lt;Args&gt;(
                 cpu.reg[GetAndThenUpdateRegIndex&lt;first_reg&gt;(reg_index)])
             ...
         };
}</code></pre>
</section>


<section><h2>Counting Registers</h2>
<p class="fragment" data-fragment-index="0"><a href="https://github.com/neobrain/presentations/blob/cpplondon_feb2018/live/live_regcount.cpp" target="_blank">Adapted example code online</a></p>

<pre style="background:#121212; width:100%; font-size:50%" class="fragment" data-fragment-index="1">
Decoding value 1
Decoding value <font color="Ultramarine Blue">2</font>
Decoding value 3
Decoding value <font color="Ultramarine Blue">0</font>
Decoding value 4
DoStartDma: dst_proc=0x1, dst_addr=2, src_proc=0x3, src_addr=0, size=4
            returning 0 and 0x240b280
Encoding value <font color="#87cefa">0   = <font color="Ultramarine Blue">2</font> * <font color="Ultramarine Blue">0</font></font>
Encoding value <font color="#32cd32">0x25ea280</font>

CPU registers on return:
<font color="#87cefa">0x0</font> <font color="#32cd32">0x25ea280</font> 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0x0 0x0 0x0 0x0 0x0 0x0
</pre>
</section>




      </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
      Reveal.initialize({
        controls: false,
        transition: 'slide',
        transitionSpeed: 'fast',
        fragments: 'false', // TODO: Disable in the final presentation!
        dependencies: [
          // Highlighting for code blocks
         { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
		// Interpret Markdown in <section> elements
		{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

		// Syntax highlight for <code> elements
		{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });

// Make left/right mouseclicks move to the next/previous slide. Disabled in the published version to make clicking on links possible.
// window.addEventListener("mousedown", handleClick, false);
// window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);
//
// function handleClick(e) {
// 	e.preventDefault();
// 	if(e.button === 0) Reveal.next();
// 	if(e.button === 2) Reveal.prev();
// }
    </script>
  </body>
</html>
